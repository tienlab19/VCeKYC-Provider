// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.19.9 clang-1700.3.19.1)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name VFTeKYC
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
import AVFoundation
import AudioToolbox
import CoreImage.CIFilterBuiltins
import Combine
import CommonCrypto
import CoreGraphics
import CoreImage
import CoreMedia
import CoreNFC
import CryptoKit
import CryptoTokenKit
import DeveloperToolsSupport
import Dispatch
import Foundation
import ImageIO
import LocalAuthentication
@_exported import LocalAuthentication/*.LAError*/
import MobileCoreServices
import OpenSSL
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UniformTypeIdentifiers
@_exported import VFTeKYC
import Vision
import WebKit
import _Concurrency
import _CoreNFC_UIKit
import _StringProcessing
import _SwiftConcurrencyShims
public enum EFQRCode {
  public static func recognize(_ image: CoreGraphics.CGImage) -> [Swift.String]
  #if compiler(>=5.3) && $NonescapableTypes
  public static func generate(for content: Swift.String, encoding: Swift.String.Encoding = .utf8, inputCorrectionLevel: VFTeKYC.EFInputCorrectionLevel = .h, size: VFTeKYC.EFIntSize = EFIntSize(width: 600, height: 600), magnification: VFTeKYC.EFIntSize? = nil, backgroundColor: CoreGraphics.CGColor = .white()!, foregroundColor: CoreGraphics.CGColor = .black()!, watermark: CoreGraphics.CGImage? = nil, watermarkMode: VFTeKYC.EFWatermarkMode = .scaleAspectFill, watermarkIsTransparent isWatermarkTransparent: Swift.Bool = true, icon: CoreGraphics.CGImage? = nil, iconSize: VFTeKYC.EFIntSize? = nil, pointStyle: any VFTeKYC.EFPointStyle = EFSquarePointStyle.square, pointOffset: CoreFoundation.CGFloat = 0, isTimingPointStyled: Swift.Bool = false, mode: VFTeKYC.EFQRCodeMode? = nil) -> CoreGraphics.CGImage?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func generateGIF(for content: Swift.String, encoding: Swift.String.Encoding = .utf8, inputCorrectionLevel: VFTeKYC.EFInputCorrectionLevel = .h, size: VFTeKYC.EFIntSize = EFIntSize(width: 600, height: 600), magnification: VFTeKYC.EFIntSize? = nil, backgroundColor: CoreGraphics.CGColor = .white()!, foregroundColor: CoreGraphics.CGColor = .black()!, watermark: Foundation.Data, watermarkMode: VFTeKYC.EFWatermarkMode = .scaleAspectFill, watermarkIsTransparent isWatermarkTransparent: Swift.Bool = true, icon: CoreGraphics.CGImage? = nil, iconSize: VFTeKYC.EFIntSize? = nil, pointStyle: any VFTeKYC.EFPointStyle = EFSquarePointStyle.square, pointOffset: CoreFoundation.CGFloat = 0, isTimingPointStyled: Swift.Bool = false, mode: VFTeKYC.EFQRCodeMode? = nil) -> Foundation.Data?
  #endif
}
public struct ORCFront : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class VFTeKYCConfig {
  public static let shared: VFTeKYC.VFTeKYCConfig
  public var headers: [Swift.String : Any]
  public var frontSideUrl: Swift.String
  public var backSideUrl: Swift.String
  public var verifyQrcodeUrl: Swift.String
  public var faceMatchingUrl: Swift.String
  public var verifyFaceUrl: Swift.String
  public var chipReaderUrl: Swift.String
  public var isFirstLogin: Swift.Bool
  public func initVFTeKYC(_ frontSideUrl: Swift.String, _ backSideUrl: Swift.String, _ verifyQrcodeUrl: Swift.String, _ verifyFaceUrl: Swift.String, _ faceMatchingUrl: Swift.String, _ chipReaderUrl: Swift.String, _ headers: [Swift.String : Any])
  @objc deinit
}
public struct VFTSimilarityIdAndSelfie : Swift.Codable {
  public let matched: Swift.Bool?
  public let similarity: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTFaceTurnVerify : Swift.Codable {
  public let faceInImage01: Swift.Bool?
  public let faceInImage02: Swift.Bool?
  public let faceInImage03: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum ReachabilityError : Swift.Error {
  case FailedToCreateWithAddress(Darwin.sockaddr_in)
  case FailedToCreateWithHostname(Swift.String)
  case UnableToSetCallback
  case UnableToSetDispatchQueue
}
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
public class Reachability {
  public typealias NetworkReachable = (VFTeKYC.Reachability) -> ()
  public typealias NetworkUnreachable = (VFTeKYC.Reachability) -> ()
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: VFTeKYC.Reachability.NetworkStatus, b: VFTeKYC.Reachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: VFTeKYC.Reachability.NetworkReachable?
  public var whenUnreachable: VFTeKYC.Reachability.NetworkUnreachable?
  public var reachableOnWWAN: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  public var currentReachabilityString: Swift.String {
    get
  }
  public var currentReachabilityStatus: VFTeKYC.Reachability.NetworkStatus {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability)
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?(hostname: Swift.String)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?()
  #endif
  @objc deinit
}
extension VFTeKYC.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  public var isReachable: Swift.Bool {
    get
  }
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct VFTFaceLivenessVerify : Swift.Codable {
  public let faceInImage01: Swift.Bool?
  public let faceInImage02: Swift.Bool?
  public let faceInImage03: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(VFTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: VFTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: VFTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (VFTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static let `default`: VFTeKYC.NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  #if compiler(>=5.3) && $NonescapableTypes
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  #endif
  open var status: VFTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?(host: Swift.String)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?()
  #endif
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping VFTeKYC.NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension VFTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: VFTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus, b: VFTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
public let AF: VFTeKYC.Session
public struct VCBackSideModel : Swift.Codable {
  public let idCard: Swift.String?
  public let expireDate: Swift.String?
  public let dob: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol ParameterEncoder {
  #if compiler(>=5.3) && $NonescapableTypes
  func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  #endif
}
open class JSONParameterEncoder : VFTeKYC.ParameterEncoder {
  public static var `default`: VFTeKYC.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: VFTeKYC.JSONParameterEncoder {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: VFTeKYC.JSONParameterEncoder {
    get
  }
  final public let encoder: Foundation.JSONEncoder
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  #if compiler(>=5.3) && $NonescapableTypes
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  #endif
  @objc deinit
}
extension VFTeKYC.ParameterEncoder where Self == VFTeKYC.JSONParameterEncoder {
  public static var json: VFTeKYC.JSONParameterEncoder {
    get
  }
  public static func json(encoder: Foundation.JSONEncoder = JSONEncoder()) -> VFTeKYC.JSONParameterEncoder
}
open class URLEncodedFormParameterEncoder : VFTeKYC.ParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: VFTeKYC.URLEncodedFormParameterEncoder.Destination, b: VFTeKYC.URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: VFTeKYC.URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: VFTeKYC.URLEncodedFormEncoder
  final public let destination: VFTeKYC.URLEncodedFormParameterEncoder.Destination
  public init(encoder: VFTeKYC.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: VFTeKYC.URLEncodedFormParameterEncoder.Destination = .methodDependent)
  #if compiler(>=5.3) && $NonescapableTypes
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  #endif
  @objc deinit
}
extension VFTeKYC.ParameterEncoder where Self == VFTeKYC.URLEncodedFormParameterEncoder {
  public static var urlEncodedForm: VFTeKYC.URLEncodedFormParameterEncoder {
    get
  }
  public static func urlEncodedForm(encoder: VFTeKYC.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: VFTeKYC.URLEncodedFormParameterEncoder.Destination = .methodDependent) -> VFTeKYC.URLEncodedFormParameterEncoder
}
public struct VFTDg13Info : Swift.Codable {
  public let ethnic: Swift.String?
  public let gender: Swift.String?
  public let religion: Swift.String?
  public let fullName: Swift.String?
  public let homeTown: Swift.String?
  public let birthDate: Swift.String?
  public let citizenPid: Swift.String?
  public let fatherName: Swift.String?
  public let motherName: Swift.String?
  public let nationality: Swift.String?
  public let outOfDate: Swift.String?
  public let dateProvide: Swift.String?
  public let oldIdentify: Swift.String?
  public let partnerName: Swift.String?
  public let regPlaceAddress: Swift.String?
  public let identifyCharacteristics: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
open class MultipartFormData {
  public static let encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  #endif
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: VFTeKYC.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
final public class URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: VFTeKYC.URLEncodedFormEncoder.ArrayEncoding, b: VFTeKYC.URLEncodedFormEncoder.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: VFTeKYC.URLEncodedFormEncoder.BoolEncoding, b: VFTeKYC.URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public struct KeyPathEncoding {
    public static let brackets: VFTeKYC.URLEncodedFormEncoder.KeyPathEncoding
    public static let dots: VFTeKYC.URLEncodedFormEncoder.KeyPathEncoding
    public init(encoding: @escaping (_ subkey: Swift.String) -> Swift.String)
  }
  public struct NilEncoding {
    public static let dropKey: VFTeKYC.URLEncodedFormEncoder.NilEncoding
    public static let dropValue: VFTeKYC.URLEncodedFormEncoder.NilEncoding
    public static let null: VFTeKYC.URLEncodedFormEncoder.NilEncoding
    #if compiler(>=5.3) && $NonescapableTypes
    public init(encoding: @escaping () -> Swift.String?)
    #endif
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: VFTeKYC.URLEncodedFormEncoder.SpaceEncoding, b: VFTeKYC.URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: VFTeKYC.URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: VFTeKYC.URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: VFTeKYC.URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: VFTeKYC.URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: VFTeKYC.URLEncodedFormEncoder.KeyEncoding
  final public let keyPathEncoding: VFTeKYC.URLEncodedFormEncoder.KeyPathEncoding
  final public let nilEncoding: VFTeKYC.URLEncodedFormEncoder.NilEncoding
  final public let spaceEncoding: VFTeKYC.URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: VFTeKYC.URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: VFTeKYC.URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: VFTeKYC.URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: VFTeKYC.URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: VFTeKYC.URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, keyPathEncoding: VFTeKYC.URLEncodedFormEncoder.KeyPathEncoding = .brackets, nilEncoding: VFTeKYC.URLEncodedFormEncoder.NilEncoding = .dropKey, spaceEncoding: VFTeKYC.URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: any Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: any Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension Foundation.CharacterSet {
  public static let afURLQueryAllowed: Foundation.CharacterSet
}
public struct VFTVerifyFace : Swift.Codable {
  public let faceQuantityVerify: VFTeKYC.VFTFaceQuantityVerify?
  public let faceMaskVerify: VFTeKYC.VFTFaceMaskVerify?
  public let faceLivenessVerify: VFTeKYC.VFTFaceLivenessVerify?
  public let faceGlassesVerify: VFTeKYC.VFTFaceGlassesVerify?
  public let faceTurnVerify: VFTeKYC.VFTFaceTurnVerify?
  public let similarityIdAndSelfie: VFTeKYC.VFTSimilarityIdAndSelfie?
  public let similarity3Faces: VFTeKYC.VFTSimilarity3Faces?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc @objcMembers final public class EFIntSize : ObjectiveC.NSObject {
  @objc final public let width: Swift.Int
  @objc final public let height: Swift.Int
  @objc public init(width: Swift.Int = 0, height: Swift.Int = 0)
  @objc convenience public init(size: CoreFoundation.CGSize)
  @objc final public var cgSize: CoreFoundation.CGSize {
    @objc get
  }
  @objc deinit
}
public struct VFTCardOverflowValid : Swift.Codable {
  public let isOverflowCrop: Swift.Bool?
  public let overflowPercent: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class VFTQrResult : Swift.Codable {
  public var cccdId: Swift.String?
  public var cmndId: Swift.String?
  public var fullName: Swift.String?
  public var dateOfBirth: Swift.String?
  public var gender: Swift.String?
  public var address: Swift.String?
  public var issueDate: Swift.String?
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public struct VFTOverExposeValid : Swift.Codable {
  public let hasOverExpose: Swift.Bool?
  public let intersectWithText: Swift.Bool?
  public let intersectWithFace: Swift.Bool?
  public let intersectFields: [Swift.String]?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTClippedCornerValid : Swift.Codable {
  public let isClipped: Swift.Bool?
  public let whichCornerIsClipped: Swift.String?
  public let clippedProbability: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTApiCheckDetail : Swift.Codable {
  public let data: VFTeKYC.VFTData?
  public let detail: Swift.String?
  public let accuracy: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc open class SessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc deinit
}
extension VFTeKYC.SessionDelegate : Foundation.URLSessionDelegate {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  #endif
}
extension VFTeKYC.SessionDelegate : Foundation.URLSessionTaskDelegate {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  #endif
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  #endif
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  #endif
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension VFTeKYC.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
  #endif
}
extension VFTeKYC.SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
@objc public enum EFWatermarkMode : Swift.Int {
  case scaleToFill = 0
  case scaleAspectFit = 1
  case scaleAspectFill = 2
  case center = 3
  case top = 4
  case bottom = 5
  case left = 6
  case right = 7
  case topLeft = 8
  case topRight = 9
  case bottomLeft = 10
  case bottomRight = 11
  public func rectForWatermark(ofSize imageSize: CoreFoundation.CGSize, inCanvasOfSize canvasSize: CoreFoundation.CGSize) -> CoreFoundation.CGRect
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct VFTOcrInfo : Swift.Codable {
  public let id: Swift.String?
  public let idProb: Swift.Double?
  public let name: Swift.String?
  public let nameProb: Swift.Double?
  public let dob: Swift.String?
  public let dobProb: Swift.Double?
  public let gender: Swift.String?
  public let genderProb: Swift.Double?
  public let hometown: Swift.String?
  public let hometownProb: Swift.Double?
  public let address: Swift.String?
  public let addressProb: Swift.Double?
  public let expired: Swift.String?
  public let expiredProb: Swift.Double?
  public let face: Swift.String?
  public let nation: Swift.String?
  public let nationProb: Swift.Int?
  public let religion: Swift.String?
  public let religionProb: Swift.Int?
  public let characteristic: Swift.String?
  public let characteristicProb: Swift.Double?
  public let issuedOn: Swift.String?
  public let issuedOnProb: Swift.Double?
  public let location: Swift.String?
  public let locationProb: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class OpenSSLUtils {
  public static func getOpenSSLError() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13, macOS 10.15, *)
  public static func getPublicKeyData(from key: Swift.OpaquePointer) -> [Swift.UInt8]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13, macOS 10.15, *)
  public static func decodePublicKeyFromBytes(pubKeyData: [Swift.UInt8], params: Swift.OpaquePointer) -> Swift.OpaquePointer?
  #endif
  public static func computeSharedSecret(privateKeyPair: Swift.OpaquePointer, publicKey: Swift.OpaquePointer) -> [Swift.UInt8]
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum CertificateType {
  case documentSigningCertificate
  case issuerSigningCertificate
  public static func == (a: VFTeKYC.CertificateType, b: VFTeKYC.CertificateType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public enum CertificateItem : Swift.String {
  case fingerprint
  case issuerName
  case subjectName
  case serialNumber
  case signatureAlgorithm
  case publicKeyAlgorithm
  case notBefore
  case notAfter
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  @available(iOS 13, macOS 10.15, *)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public class X509Wrapper {
  final public let cert: Swift.OpaquePointer
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(with cert: Swift.OpaquePointer?)
  #endif
  public func getItemsAsDict() -> [VFTeKYC.CertificateItem : Swift.String]
  public func certToPEM() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public func getFingerprint() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getNotBeforeDate() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getNotAfterDate() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getSerialNumber() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getSignatureAlgorithm() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getPublicKeyAlgorithm() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getIssuerName() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getSubjectName() -> Swift.String?
  #endif
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public class ASN1Item : Swift.CustomDebugStringConvertible {
  public init(line: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  public func getChild(_ child: Swift.Int) -> VFTeKYC.ASN1Item?
  #endif
  public func getNumberOfChildren() -> Swift.Int
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public class SimpleASN1DumpParser {
  public init()
  public func parse(data: Foundation.Data) throws -> VFTeKYC.ASN1Item
  public func test()
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum DataGroupId : Swift.Int, Swift.CaseIterable {
  case COM
  case DG1
  case DG2
  case DG3
  case DG4
  case DG5
  case DG6
  case DG7
  case DG8
  case DG9
  case DG10
  case DG11
  case DG12
  case DG13
  case DG14
  case DG15
  case DG16
  case SOD
  case Unknown
  public func getName() -> Swift.String
  public static func getIDFromName(name: Swift.String) -> VFTeKYC.DataGroupId
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  @available(iOS 13, macOS 10.15, *)
  public typealias AllCases = [VFTeKYC.DataGroupId]
  @available(iOS 13, macOS 10.15, *)
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [VFTeKYC.DataGroupId] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class COM : VFTeKYC.DataGroup {
  public var version: Swift.String {
    get
  }
  public var unicodeVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public func AESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func AESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func AESECBEncrypt(key: [Swift.UInt8], message: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func tripleDESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func tripleDESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func DESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func DESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ChipAuthenticationInfo : VFTeKYC.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
public func binToHexRep(_ val: [Swift.UInt8], asArray: Swift.Bool = false) -> Swift.String
public func binToHexRep(_ val: Swift.UInt8) -> Swift.String
public func binToHex(_ val: Swift.UInt8) -> Swift.Int
public func binToHex(_ val: [Swift.UInt8]) -> Swift.UInt64
public func binToHex(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.UInt64
public func hexToBin(_ val: Swift.UInt64) -> [Swift.UInt8]
public func binToInt(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.Int
public func binToInt(_ val: [Swift.UInt8]) -> Swift.Int
public func intToBin(_ data: Swift.Int, pad: Swift.Int = 2) -> [Swift.UInt8]
public func hexRepToBin(_ val: Swift.String) -> [Swift.UInt8]
public func xor(_ kifd: [Swift.UInt8], _ response_kicc: [Swift.UInt8]) -> [Swift.UInt8]
public func generateRandomUInt8Array(_ size: Swift.Int) -> [Swift.UInt8]
public func pad(_ toPad: [Swift.UInt8], blockSize: Swift.Int) -> [Swift.UInt8]
public func unpad(_ tounpad: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func mac(algoName: VFTeKYC.SecureMessagingSupportedAlgorithms, key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func desMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func aesMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func wrapDO(b: Swift.UInt8, arr: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func unwrapDO(tag: Swift.UInt8, wrappedData: [Swift.UInt8]) throws -> [Swift.UInt8]
public func intToBytes(val: Swift.Int, removePadding: Swift.Bool) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func oidToBytes(oid: Swift.String, replaceTag: Swift.Bool) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func asn1Length(_ data: Swift.ArraySlice<Swift.UInt8>) throws -> (Swift.Int, Swift.Int)
@available(iOS 13, macOS 10.15, *)
public func asn1Length(_ data: [Swift.UInt8]) throws -> (Swift.Int, Swift.Int)
@available(iOS 13, macOS 10.15, *)
public func toAsn1Length(_ data: Swift.Int) throws -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcHash(data: [Swift.UInt8], hashAlgorithm: Swift.String) throws -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA1Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA224Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA256Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA512Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA384Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup15 : VFTeKYC.DataGroup {
  public var rsaPublicKey: Swift.OpaquePointer? {
    get
  }
  public var ecdsaPublicKey: Swift.OpaquePointer? {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class CardAccess {
  public var securityInfos: [VFTeKYC.SecurityInfo] {
    get
  }
  @objc deinit
}
@available(iOS 13, *)
public struct ResponseAPDU {
  public var data: [Swift.UInt8]
  public var sw1: Swift.UInt8
  public var sw2: Swift.UInt8
  public init(data: [Swift.UInt8], sw1: Swift.UInt8, sw2: Swift.UInt8)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class NotImplementedDG : VFTeKYC.DataGroup {
  @objc deinit
}
public enum SecureMessagingSupportedAlgorithms {
  case DES
  case AES
  public static func == (a: VFTeKYC.SecureMessagingSupportedAlgorithms, b: VFTeKYC.SecureMessagingSupportedAlgorithms) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, *)
public class SecureMessaging {
  public init(encryptionAlgorithm: VFTeKYC.SecureMessagingSupportedAlgorithms = .DES, ksenc: [Swift.UInt8], ksmac: [Swift.UInt8], ssc: [Swift.UInt8])
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum NFCViewDisplayMessage {
  case requestPresentPassport
  case authenticatingWithPassport(Swift.Int)
  case readingDataGroupProgress(VFTeKYC.DataGroupId, Swift.Int)
  case error(VFTeKYC.NFCPassportReaderError)
  case successfulRead
}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.NFCViewDisplayMessage {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class SecurityInfo {
  public func getObjectIdentifier() -> Swift.String
  public func getProtocolOIDString() -> Swift.String
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup14 : VFTeKYC.DataGroup {
  public var securityInfos: [VFTeKYC.SecurityInfo] {
    get
  }
  @objc deinit
}
@available(iOS 13, *)
public class PACEHandler {
  public init(cardAccess: VFTeKYC.CardAccess, tagReader: VFTeKYC.TagReader) throws
  public func doPACE(mrzKey: Swift.String, completed: @escaping (Swift.Bool) -> ())
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup2 : VFTeKYC.DataGroup {
  public var nrImages: Swift.Int {
    get
  }
  public var versionNumber: Swift.Int {
    get
  }
  public var lengthOfRecord: Swift.Int {
    get
  }
  public var numberOfFacialImages: Swift.Int {
    get
  }
  public var facialRecordDataLength: Swift.Int {
    get
  }
  public var nrFeaturePoints: Swift.Int {
    get
  }
  public var gender: Swift.Int {
    get
  }
  public var eyeColor: Swift.Int {
    get
  }
  public var hairColor: Swift.Int {
    get
  }
  public var featureMask: Swift.Int {
    get
  }
  public var expression: Swift.Int {
    get
  }
  public var poseAngle: Swift.Int {
    get
  }
  public var poseAngleUncertainty: Swift.Int {
    get
  }
  public var faceImageType: Swift.Int {
    get
  }
  public var imageDataType: Swift.Int {
    get
  }
  public var imageWidth: Swift.Int {
    get
  }
  public var imageHeight: Swift.Int {
    get
  }
  public var imageColorSpace: Swift.Int {
    get
  }
  public var sourceType: Swift.Int {
    get
  }
  public var deviceType: Swift.Int {
    get
  }
  public var quality: Swift.Int {
    get
  }
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum NFCPassportReaderError : Swift.Error {
  case ResponseError(Swift.String, Swift.UInt8, Swift.UInt8)
  case InvalidResponse
  case UnexpectedError
  case NFCNotSupported
  case NoConnectedTag
  case D087Malformed
  case InvalidResponseChecksum
  case MissingMandatoryFields
  case CannotDecodeASN1Length
  case InvalidASN1Value
  case UnableToProtectAPDU
  case UnableToUnprotectAPDU
  case UnsupportedDataGroup
  case DataGroupNotRead
  case UnknownTag
  case UnknownImageFormat
  case NotImplemented
  case TagNotValid
  case ConnectionError
  case UserCanceled
  case InvalidMRZKey
  case MoreThanOneTagFound
  case InvalidHashAlgorithmSpecified
  case InvalidDataPassed(Swift.String)
  case NotYetSupported(Swift.String)
}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.NFCPassportReaderError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
@available(iOS 13, macOS 10.15, *)
public enum OpenSSLError : Swift.Error {
  case UnableToGetX509CertificateFromPKCS7(Swift.String)
  case UnableToVerifyX509CertificateForSOD(Swift.String)
  case VerifyAndReturnSODEncapsulatedData(Swift.String)
  case UnableToReadECPublicKey(Swift.String)
  case UnableToExtractSignedDataFromPKCS7(Swift.String)
  case VerifySignedAttributes(Swift.String)
  case UnableToParseASN1(Swift.String)
  case UnableToDecryptRSASignature(Swift.String)
}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.OpenSSLError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
public enum PassiveAuthenticationError : Swift.Error {
  case UnableToParseSODHashes(Swift.String)
  case InvalidDataGroupHash(Swift.String)
  case SODMissing(Swift.String)
}
extension VFTeKYC.PassiveAuthenticationError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ActiveAuthenticationInfo : VFTeKYC.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public func getSignatureAlgorithmOIDString() -> Swift.String?
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ChipAuthenticationPublicKeyInfo : VFTeKYC.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  @objc deinit
}
public enum PassportAuthenticationStatus {
  case notDone
  case success
  case failed
  public static func == (a: VFTeKYC.PassportAuthenticationStatus, b: VFTeKYC.PassportAuthenticationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public class NFCPassportModel {
  public var documentType: Swift.String {
    get
  }
  public var documentSubType: Swift.String {
    get
  }
  public var documentNumber: Swift.String {
    get
  }
  public var issuingAuthority: Swift.String {
    get
  }
  public var documentExpiryDate: Swift.String {
    get
  }
  public var dateOfBirth: Swift.String {
    get
  }
  public var gender: Swift.String {
    get
  }
  public var nationality: Swift.String {
    get
  }
  public var lastName: Swift.String {
    get
  }
  public var firstName: Swift.String {
    get
  }
  public var passportMRZ: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var placeOfBirth: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var residenceAddress: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var phoneNumber: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var personalNumber: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var documentSigningCertificate: VFTeKYC.X509Wrapper? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var countrySigningCertificate: VFTeKYC.X509Wrapper? {
    get
  }
  #endif
  public var LDSVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  public var dataGroupsAvailable: [VFTeKYC.DataGroupId] {
    get
  }
  public var dataGroupsRead: [VFTeKYC.DataGroupId : VFTeKYC.DataGroup] {
    get
  }
  public var dataGroupHashes: [VFTeKYC.DataGroupId : VFTeKYC.DataGroupHash] {
    get
  }
  public var cardAccess: VFTeKYC.CardAccess? {
    get
  }
  public var BACStatus: VFTeKYC.PassportAuthenticationStatus {
    get
  }
  public var PACEStatus: VFTeKYC.PassportAuthenticationStatus {
    get
  }
  public var chipAuthenticationStatus: VFTeKYC.PassportAuthenticationStatus {
    get
  }
  public var passportCorrectlySigned: Swift.Bool {
    get
  }
  public var documentSigningCertificateVerified: Swift.Bool {
    get
  }
  public var passportDataNotTampered: Swift.Bool {
    get
  }
  public var activeAuthenticationPassed: Swift.Bool {
    get
  }
  public var activeAuthenticationChallenge: [Swift.UInt8] {
    get
  }
  public var activeAuthenticationSignature: [Swift.UInt8] {
    get
  }
  public var verificationErrors: [any Swift.Error] {
    get
  }
  public var isPACESupported: Swift.Bool {
    get
  }
  public var isChipAuthenticationSupported: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var passportImage: UIKit.UIImage? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var signatureImage: UIKit.UIImage? {
    get
  }
  #endif
  public var activeAuthenticationSupported: Swift.Bool {
    get
  }
  public init()
  public init(from dump: [Swift.String : Swift.String])
  public func addDataGroup(_ id: VFTeKYC.DataGroupId, dataGroup: VFTeKYC.DataGroup)
  #if compiler(>=5.3) && $NonescapableTypes
  public func getDataGroup(_ id: VFTeKYC.DataGroupId) -> VFTeKYC.DataGroup?
  #endif
  public func dumpPassportData(selectedDataGroups: [VFTeKYC.DataGroupId], includeActiveAuthenticationData: Swift.Bool = false) -> [Swift.String : Swift.String]
  public func getHashesForDatagroups(hashAlgorythm: Swift.String) -> [VFTeKYC.DataGroupId : [Swift.UInt8]]
  #if compiler(>=5.3) && $NonescapableTypes
  public func verifyPassport(masterListURL: Foundation.URL?, useCMSVerification: Swift.Bool = false)
  #endif
  public func verifyActiveAuthentication(challenge: [Swift.UInt8], signature: [Swift.UInt8])
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup {
  public var datagroupType: VFTeKYC.DataGroupId
  public var body: [Swift.UInt8] {
    get
  }
  public var data: [Swift.UInt8] {
    get
  }
  public func hash(_ hashAlgorythm: Swift.String) -> [Swift.UInt8]
  @objc deinit
}
@available(iOS 13, *)
public class BACHandler {
  public var ksenc: [Swift.UInt8]
  public var ksmac: [Swift.UInt8]
  public var kifd: [Swift.UInt8]
  public init()
  public init(tagReader: VFTeKYC.TagReader)
  #if compiler(>=5.3) && $NonescapableTypes
  public func performBACAndGetSessionKeys(mrzKey: Swift.String, completed: @escaping (_ error: VFTeKYC.NFCPassportReaderError?) -> ())
  #endif
  public func sessionKeys(data: [Swift.UInt8]) throws -> ([Swift.UInt8], [Swift.UInt8], [Swift.UInt8])
  @objc deinit
}
public enum LogLevel : Swift.Int, Swift.CaseIterable {
  case verbose
  case debug
  case info
  case warning
  case error
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias AllCases = [VFTeKYC.LogLevel]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [VFTeKYC.LogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Log {
  public static var logLevel: VFTeKYC.LogLevel
  public static var storeLogs: Swift.Bool
  public static var logData: [Swift.String]
  public class func verbose(_ msg: @autoclosure () -> Swift.String)
  public class func debug(_ msg: @autoclosure () -> Swift.String)
  public class func info(_ msg: @autoclosure () -> Swift.String)
  public class func warning(_ msg: @autoclosure () -> Swift.String)
  public class func error(_ msg: @autoclosure () -> Swift.String)
  public class func clearStoredLogs()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup11 : VFTeKYC.DataGroup {
  public var fullName: Swift.String? {
    get
  }
  public var personalNumber: Swift.String? {
    get
  }
  public var dateOfBirth: Swift.String? {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var address: Swift.String? {
    get
  }
  public var telephone: Swift.String? {
    get
  }
  public var profession: Swift.String? {
    get
  }
  public var title: Swift.String? {
    get
  }
  public var personalSummary: Swift.String? {
    get
  }
  public var proofOfCitizenship: Swift.String? {
    get
  }
  public var tdNumbers: Swift.String? {
    get
  }
  public var custodyInfo: Swift.String? {
    get
  }
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum DocTypeEnum : Swift.String {
  case TD1
  case TD2
  case OTHER
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  @available(iOS 13, macOS 10.15, *)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup1 : VFTeKYC.DataGroup {
  public var elements: [Swift.String : Swift.String] {
    get
  }
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public struct DataGroupHash {
  public var id: Swift.String
  public var sodHash: Swift.String
  public var computedHash: Swift.String
  public var match: Swift.Bool
}
@objc @available(iOS 13, *)
public class PassportReader : ObjectiveC.NSObject {
  public var passiveAuthenticationUsesOpenSSL: Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public init(logLevel: VFTeKYC.LogLevel = .info, masterListURL: Foundation.URL? = nil)
  #endif
  public func setMasterListURL(_ masterListURL: Foundation.URL)
  public func overrideNFCDataAmountToRead(amount: Swift.Int)
  #if compiler(>=5.3) && $NonescapableTypes
  public func readPassport(mrzKey: Swift.String, tags: [VFTeKYC.DataGroupId] = [], skipSecureElements: Swift.Bool = true, skipCA: Swift.Bool = false, skipPACE: Swift.Bool = false, customDisplayMessage: ((VFTeKYC.NFCViewDisplayMessage) -> Swift.String?)? = nil, completed: @escaping (VFTeKYC.NFCPassportModel?, VFTeKYC.NFCPassportReaderError?) -> ())
  #endif
  @objc deinit
}
@available(iOS 13, *)
extension VFTeKYC.PassportReader : CoreNFC.NFCTagReaderSessionDelegate {
  public func tagReaderSessionDidBecomeActive(_ session: CoreNFC.NFCTagReaderSession)
  public func tagReaderSession(_ session: CoreNFC.NFCTagReaderSession, didInvalidateWithError error: any Swift.Error)
  public func tagReaderSession(_ session: CoreNFC.NFCTagReaderSession, didDetect tags: [CoreNFC.NFCTag])
}
public enum PACEMappingType {
  case GM
  case IM
  case CAM
  public static func == (a: VFTeKYC.PACEMappingType, b: VFTeKYC.PACEMappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class PACEInfo : VFTeKYC.SecurityInfo {
  public static let PARAM_ID_GFP_1024_160: Swift.Int
  public static let PARAM_ID_GFP_2048_224: Swift.Int
  public static let PARAM_ID_GFP_2048_256: Swift.Int
  public static let PARAM_ID_ECP_NIST_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P320_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P512_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P521_R1: Swift.Int
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getVersion() -> Swift.Int
  #if compiler(>=5.3) && $NonescapableTypes
  public func getParameterId() -> Swift.Int?
  #endif
  public func getParameterSpec() throws -> Swift.Int32
  public func getMappingType() throws -> VFTeKYC.PACEMappingType
  public func getKeyAgreementAlgorithm() throws -> Swift.String
  public func getCipherAlgorithm() throws -> Swift.String
  public func getDigestAlgorithm() throws -> Swift.String
  public func getKeyLength() throws -> Swift.Int
  public func createMappingKey() throws -> Swift.OpaquePointer
  public static func getParameterSpec(stdDomainParam: Swift.Int) throws -> Swift.Int32
  public static func toMappingType(oid: Swift.String) throws -> VFTeKYC.PACEMappingType
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toDigestAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup7 : VFTeKYC.DataGroup {
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, *)
public class TagReader {
  @objc deinit
}
public struct VFTVerifyFaceLiveness : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTData : Swift.Codable {
  public let mrz: Swift.String?
  public let sex: Swift.String?
  public let name: Swift.String?
  public let nation: Swift.String?
  public let address: Swift.String?
  public let hometown: Swift.String?
  public let religion: Swift.String?
  public let character: Swift.String?
  public let faceImage: Swift.String?
  public let issueDate: Swift.String?
  public let cardNumber: Swift.String?
  public let fatherName: Swift.String?
  public let motherName: Swift.String?
  public let dateOfBirth: Swift.String?
  public let expiredDate: Swift.String?
  public let nationality: Swift.String?
  public let partnerName: Swift.String?
  public let previousNumber: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias BAFailureBlock = ((_ error: LocalAuthentication.LAError?) -> Swift.Void)?
public typealias BASuccessBlock = (() -> Swift.Void)?
public class BiometricAuthenticator {
  public init()
  public var defaultAuthenticationReason: Swift.String
  public var defaultFallbackButtonTitle: Swift.String?
  public var defaultFallbackAlertTitle: Swift.String?
  public func isTouchIdSupportedOnDevice() -> Swift.Bool
  public func isTouchIdEnabledOnDevice() -> Swift.Bool
  public func isFaceIdSupportedOnDevice() -> Swift.Bool
  public func isFaceIdEnabledOnDevice() -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public func authenticateWithBiometrics(localizedReason: Swift.String? = nil, successBlock: VFTeKYC.BASuccessBlock, failureBlock: VFTeKYC.BAFailureBlock)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func authenticateWithPasscode(localizedReason: Swift.String? = nil, successBlock: VFTeKYC.BASuccessBlock, failureBlock: VFTeKYC.BAFailureBlock)
  #endif
  public func invalidateAuthenticationContext()
  @objc deinit
}
public enum EFQRCodeMode {
  @available(*, deprecated, message: "Use `nil` instead.")
  case none
  case grayscale
  case binarization(threshold: CoreFoundation.CGFloat)
}
public protocol RedirectHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
  #endif
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static let follow: VFTeKYC.Redirector
  public static let doNotFollow: VFTeKYC.Redirector
  public let behavior: VFTeKYC.Redirector.Behavior
  public init(behavior: VFTeKYC.Redirector.Behavior)
}
extension VFTeKYC.Redirector : VFTeKYC.RedirectHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
  #endif
}
extension VFTeKYC.RedirectHandler where Self == VFTeKYC.Redirector {
  public static var follow: VFTeKYC.Redirector {
    get
  }
  public static var doNotFollow: VFTeKYC.Redirector {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public static func modify(using closure: @escaping (Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?) -> VFTeKYC.Redirector
  #endif
}
@_hasMissingDesignatedInitializers public class VFTeKYCSDK {
  public static func initVFTeKYC(frontSideUrl: Swift.String, backSideUrl: Swift.String, verifyQrcodeUrl: Swift.String, verifyFaceUrl: Swift.String, faceMatchingUrl: Swift.String, chipReaderUrl: Swift.String, headers: [Swift.String : Any])
  #if compiler(>=5.3) && $NonescapableTypes
  public static func backSideVinFast(image: UIKit.UIImage, success: ((VFTeKYC.VCBackSideModel) -> Swift.Void)?, failed: ((Swift.String, Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func frontSideVinFast(image: UIKit.UIImage, success: ((VFTeKYC.VFTFrontSide) -> Swift.Void)?, failed: ((Swift.String, Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func verifyQRCode_VF(image: UIKit.UIImage?, success: ((VFTeKYC.VFTQrResult?) -> Swift.Void)?, failed: ((Swift.String, Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func faceliveness1(image: UIKit.UIImage?, success: ((VFTeKYC.VFTVerifyFaceLiveness) -> Swift.Void)?, failed: ((Swift.String, Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func faceliveness2(image: UIKit.UIImage?, leftImage: UIKit.UIImage?, rightImage: UIKit.UIImage?, success: ((VFTeKYC.VFTVerifyFaceLiveness) -> Swift.Void)?, failed: ((Swift.String, Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func facematching(success: ((VFTeKYC.VFTFaceMatching) -> Swift.Void)?, failed: ((Swift.String, Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func frontSide(image: UIKit.UIImage, success: ((VFTeKYC.VFTFrontSide) -> Swift.Void)?, failed: ((Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func backSide(image: UIKit.UIImage, success: ((VFTeKYC.VFTBackSide) -> Swift.Void)?, failed: ((Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func verifyQRCode(image: UIKit.UIImage?, success: ((VFTeKYC.VFTQrResult?) -> Swift.Void)?, failed: ((Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func compareFace(frontImage: UIKit.UIImage?, faceImage: UIKit.UIImage?, success: ((VFTeKYC.VFTVerifyFaceLiveness, VFTeKYC.VFTFaceMatching) -> Swift.Void)?, failed: ((Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func verifyFace(faceSefie: UIKit.UIImage?, frontCardFile: UIKit.UIImage?, faceLivenessSuccess: ((VFTeKYC.VFTVerifyFaceLiveness, VFTeKYC.VFTFaceMatching) -> Swift.Void)?, failed: ((Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func startFaceLivenessOnly(fromVC: UIKit.UIViewController, isEKYC1Face: Swift.Bool, isShowIntoScreen: Swift.Bool, onVerifyFaceSuccess: ((VFTeKYC.VFTVerifyFaceLiveness, [UIKit.UIImage]) -> Swift.Void)?, onVerifyFaceFailure: ((Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13, *)
  public static func chipReader(callApiValid: Swift.Bool, chipCardInfo: VFTeKYC.ChipCardInfo, success: ((VFTeKYC.VFTValidateChip) -> Swift.Void)?, failed: ((Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func startEKYC(fromVC: UIKit.UIViewController, isEKYC1Face: Swift.Bool, setShowScreenIntroOCR: Swift.Bool, onFrontSideSuccess: ((VFTeKYC.VFTFrontSide, UIKit.UIImage) -> Swift.Void)?, onFrontSideFailure: ((Swift.String) -> Swift.Void)?, onVerifyQRImage: ((VFTeKYC.VFTQrResult?, UIKit.UIImage) -> Swift.Void)?, onVerifyQRFailure: ((Swift.String) -> Swift.Void)?, onBackSideSuccess: ((VFTeKYC.VFTBackSide, UIKit.UIImage) -> Swift.Void)?, onBackSideFailure: ((Swift.String) -> Swift.Void)?, onVerifyFaceSuccess: ((VFTeKYC.VFTVerifyFaceLiveness, VFTeKYC.VFTFaceMatching, [UIKit.UIImage]) -> Swift.Void)?, onVerifyFaceFailure: ((Swift.String) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func startOCR(fromVC: UIKit.UIViewController, setShowScreenIntroOCR: Swift.Bool, onFrontSideSuccess: ((VFTeKYC.VFTFrontSide, UIKit.UIImage) -> Swift.Void)?, onFrontSideFailure: ((Swift.String) -> Swift.Void)?, onVerifyQRImage: ((VFTeKYC.VFTQrResult?, UIKit.UIImage) -> Swift.Void)?, onVerifyQRFailure: ((Swift.String) -> Swift.Void)?, onBackSideSuccess: ((VFTeKYC.VFTBackSide, UIKit.UIImage) -> Swift.Void)?, onBackSideFailure: ((Swift.String) -> Swift.Void)?)
  #endif
  public static func startEKYC(fromVC: UIKit.UIViewController, completion: @escaping (_ response: Swift.Int) -> Swift.Void)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13, *)
  public static func startNFC(birthdate: Swift.String, expiryDate: Swift.String, documentNumber: Swift.String, viewController: UIKit.UIViewController, customDisplayMessage: ((VFTeKYC.NFCViewDisplayMessage) -> Swift.String?)? = nil, completed: @escaping (VFTeKYC.NFCPassportModel?, VFTeKYC.NFCPassportReaderError?) -> ())
  #endif
  @objc deinit
}
public struct VFTPhotocopyValid : Swift.Codable {
  public let isPhotocopy: Swift.Bool?
  public let photocopyScore: Swift.Double?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc public enum EFInputCorrectionLevel : Swift.Int {
  case l = 0
  case m = 1
  case q = 2
  case h = 3
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct HTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static let connect: VFTeKYC.HTTPMethod
  public static let delete: VFTeKYC.HTTPMethod
  public static let get: VFTeKYC.HTTPMethod
  public static let head: VFTeKYC.HTTPMethod
  public static let options: VFTeKYC.HTTPMethod
  public static let patch: VFTeKYC.HTTPMethod
  public static let post: VFTeKYC.HTTPMethod
  public static let put: VFTeKYC.HTTPMethod
  public static let query: VFTeKYC.HTTPMethod
  public static let trace: VFTeKYC.HTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public struct VFTFaceQuantityVerify : Swift.Codable {
  public let faceInImage01: Swift.Int?
  public let faceInImage02: Swift.Int?
  public let faceInImage03: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RequestAdapterState {
  public let requestID: Foundation.UUID
  public let session: VFTeKYC.Session
}
public protocol RequestAdapter {
  #if compiler(>=5.3) && $NonescapableTypes
  func adapt(_ urlRequest: Foundation.URLRequest, for session: VFTeKYC.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func adapt(_ urlRequest: Foundation.URLRequest, using state: VFTeKYC.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  #endif
}
extension VFTeKYC.RequestAdapter {
  #if compiler(>=5.3) && $NonescapableTypes
  public func adapt(_ urlRequest: Foundation.URLRequest, using state: VFTeKYC.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  #endif
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(any Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ request: VFTeKYC.Request, for session: VFTeKYC.Session, dueTo error: any Swift.Error, completion: @escaping (VFTeKYC.RetryResult) -> Swift.Void)
}
public protocol RequestInterceptor : VFTeKYC.RequestAdapter, VFTeKYC.RequestRetrier {
}
extension VFTeKYC.RequestInterceptor {
  #if compiler(>=5.3) && $NonescapableTypes
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: VFTeKYC.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  #endif
  public func retry(_ request: VFTeKYC.Request, for session: VFTeKYC.Session, dueTo error: any Swift.Error, completion: @escaping (VFTeKYC.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, VFTeKYC.Session, _ completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (VFTeKYC.Request, VFTeKYC.Session, any Swift.Error, _ completion: @escaping (VFTeKYC.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : VFTeKYC.RequestInterceptor {
  public init(_ adaptHandler: @escaping VFTeKYC.AdaptHandler)
  #if compiler(>=5.3) && $NonescapableTypes
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: VFTeKYC.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: VFTeKYC.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  #endif
  @objc deinit
}
extension VFTeKYC.RequestAdapter where Self == VFTeKYC.Adapter {
  public static func adapter(using closure: @escaping VFTeKYC.AdaptHandler) -> VFTeKYC.Adapter
}
open class Retrier : VFTeKYC.RequestInterceptor {
  public init(_ retryHandler: @escaping VFTeKYC.RetryHandler)
  open func retry(_ request: VFTeKYC.Request, for session: VFTeKYC.Session, dueTo error: any Swift.Error, completion: @escaping (VFTeKYC.RetryResult) -> Swift.Void)
  @objc deinit
}
extension VFTeKYC.RequestRetrier where Self == VFTeKYC.Retrier {
  public static func retrier(using closure: @escaping VFTeKYC.RetryHandler) -> VFTeKYC.Retrier
}
open class Interceptor : VFTeKYC.RequestInterceptor {
  final public let adapters: [any VFTeKYC.RequestAdapter]
  final public let retriers: [any VFTeKYC.RequestRetrier]
  public init(adaptHandler: @escaping VFTeKYC.AdaptHandler, retryHandler: @escaping VFTeKYC.RetryHandler)
  public init(adapter: any VFTeKYC.RequestAdapter, retrier: any VFTeKYC.RequestRetrier)
  public init(adapters: [any VFTeKYC.RequestAdapter] = [], retriers: [any VFTeKYC.RequestRetrier] = [], interceptors: [any VFTeKYC.RequestInterceptor] = [])
  #if compiler(>=5.3) && $NonescapableTypes
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: VFTeKYC.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: VFTeKYC.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  #endif
  open func retry(_ request: VFTeKYC.Request, for session: VFTeKYC.Session, dueTo error: any Swift.Error, completion: @escaping (VFTeKYC.RetryResult) -> Swift.Void)
  @objc deinit
}
extension VFTeKYC.RequestInterceptor where Self == VFTeKYC.Interceptor {
  public static func interceptor(adapter: @escaping VFTeKYC.AdaptHandler, retrier: @escaping VFTeKYC.RetryHandler) -> VFTeKYC.Interceptor
  public static func interceptor(adapter: any VFTeKYC.RequestAdapter, retrier: any VFTeKYC.RequestRetrier) -> VFTeKYC.Interceptor
  public static func interceptor(adapters: [any VFTeKYC.RequestAdapter] = [], retriers: [any VFTeKYC.RequestRetrier] = [], interceptors: [any VFTeKYC.RequestInterceptor] = []) -> VFTeKYC.Interceptor
}
public typealias AFResult<Success> = Swift.Result<Success, VFTeKYC.AFError>
public struct VFTFaceGlassesVerify : Swift.Codable {
  public let faceInImage01: Swift.Bool?
  public let faceInImage02: Swift.Bool?
  public let faceInImage03: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTSimilarity3Faces : Swift.Codable {
  public let matched: Swift.Bool?
  public let similarity: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTValidateChip : Swift.Codable {
  public let statusCode: Swift.Int?
  public let c06StatusCode: Swift.Int?
  public let xgwTransactionId: Swift.String?
  public let validateChipData: VFTeKYC.VFTValidateChipData?
  public func toDictionary() -> [Swift.String : Any]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTValidateChipData : Swift.Codable {
  public func toDictionary() -> [Swift.String : Any]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  #if compiler(>=5.3) && $NonescapableTypes
  func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Self.SerializedObject
  #endif
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  #if compiler(>=5.3) && $NonescapableTypes
  func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Self.SerializedObject
  #endif
}
public protocol ResponseSerializer : VFTeKYC.DataResponseSerializerProtocol, VFTeKYC.DownloadResponseSerializerProtocol {
  var dataPreprocessor: any VFTeKYC.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : VFTeKYC.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : VFTeKYC.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension VFTeKYC.DataPreprocessor where Self == VFTeKYC.PassthroughPreprocessor {
  public static var passthrough: VFTeKYC.PassthroughPreprocessor {
    get
  }
}
extension VFTeKYC.DataPreprocessor where Self == VFTeKYC.GoogleXSSIPreprocessor {
  public static var googleXSSI: VFTeKYC.GoogleXSSIPreprocessor {
    get
  }
}
extension VFTeKYC.ResponseSerializer {
  public static var defaultDataPreprocessor: any VFTeKYC.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: any VFTeKYC.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func requestAllowsEmptyResponseData(_ request: Foundation.URLRequest?) -> Swift.Bool?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func emptyResponseAllowed(forRequest request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
  #endif
}
extension VFTeKYC.DownloadResponseSerializerProtocol where Self : VFTeKYC.DataResponseSerializerProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Self.SerializedObject
  #endif
}
extension VFTeKYC.DataRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (VFTeKYC.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  #endif
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (VFTeKYC.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : VFTeKYC.DataResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (VFTeKYC.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : VFTeKYC.ResponseSerializer
}
extension VFTeKYC.DownloadRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (VFTeKYC.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  #endif
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (VFTeKYC.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : VFTeKYC.DownloadResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (VFTeKYC.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : VFTeKYC.ResponseSerializer
}
public struct URLResponseSerializer : VFTeKYC.DownloadResponseSerializerProtocol {
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Foundation.URL
  #endif
  public typealias SerializedObject = Foundation.URL
}
extension VFTeKYC.DownloadResponseSerializerProtocol where Self == VFTeKYC.URLResponseSerializer {
  public static var url: VFTeKYC.URLResponseSerializer {
    get
  }
}
extension VFTeKYC.DownloadRequest {
  @discardableResult
  public func responseURL(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (VFTeKYC.AFDownloadResponse<Foundation.URL>) -> Swift.Void) -> Self
}
final public class DataResponseSerializer : VFTeKYC.ResponseSerializer {
  final public let dataPreprocessor: any VFTeKYC.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod>
  public init(dataPreprocessor: any VFTeKYC.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Foundation.Data
  #endif
  public typealias SerializedObject = Foundation.Data
  @objc deinit
}
extension VFTeKYC.ResponseSerializer where Self == VFTeKYC.DataResponseSerializer {
  public static var data: VFTeKYC.DataResponseSerializer {
    get
  }
  public static func data(dataPreprocessor: any VFTeKYC.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> VFTeKYC.DataResponseSerializer
}
extension VFTeKYC.DataRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any VFTeKYC.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (VFTeKYC.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension VFTeKYC.DownloadRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any VFTeKYC.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (VFTeKYC.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : VFTeKYC.ResponseSerializer {
  final public let dataPreprocessor: any VFTeKYC.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod>
  #if compiler(>=5.3) && $NonescapableTypes
  public init(dataPreprocessor: any VFTeKYC.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Swift.String
  #endif
  public typealias SerializedObject = Swift.String
  @objc deinit
}
extension VFTeKYC.ResponseSerializer where Self == VFTeKYC.StringResponseSerializer {
  public static var string: VFTeKYC.StringResponseSerializer {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public static func string(dataPreprocessor: any VFTeKYC.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> VFTeKYC.StringResponseSerializer
  #endif
}
extension VFTeKYC.DataRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any VFTeKYC.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (VFTeKYC.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
  #endif
}
extension VFTeKYC.DownloadRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any VFTeKYC.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (VFTeKYC.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
  #endif
}
@available(*, deprecated, message: "JSONResponseSerializer deprecated and will be removed in Alamofire 6. Use DecodableResponseSerializer instead.")
final public class JSONResponseSerializer : VFTeKYC.ResponseSerializer {
  final public let dataPreprocessor: any VFTeKYC.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: any VFTeKYC.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Any
  #endif
  @available(*, deprecated, message: "JSONResponseSerializer deprecated and will be removed in Alamofire 6. Use DecodableResponseSerializer instead.")
  public typealias SerializedObject = Any
  @objc deinit
}
extension VFTeKYC.DataRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any VFTeKYC.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (VFTeKYC.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension VFTeKYC.DownloadRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any VFTeKYC.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (VFTeKYC.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static let value: VFTeKYC.Empty
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension VFTeKYC.Empty : VFTeKYC.EmptyResponse {
  public static func emptyValue() -> VFTeKYC.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension Foundation.JSONDecoder : VFTeKYC.DataDecoder {
}
extension Foundation.PropertyListDecoder : VFTeKYC.DataDecoder {
}
final public class DecodableResponseSerializer<T> : VFTeKYC.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: any VFTeKYC.DataPreprocessor
  final public let decoder: any VFTeKYC.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod>
  public init(dataPreprocessor: any VFTeKYC.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> T
  #endif
  public typealias SerializedObject = T
  @objc deinit
}
extension VFTeKYC.ResponseSerializer {
  public static func decodable<T>(of type: T.Type, dataPreprocessor: any VFTeKYC.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> VFTeKYC.DecodableResponseSerializer<T> where Self == VFTeKYC.DecodableResponseSerializer<T>, T : Swift.Decodable
}
extension VFTeKYC.DataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any VFTeKYC.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (VFTeKYC.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension VFTeKYC.DownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any VFTeKYC.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (VFTeKYC.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : VFTeKYC.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: any VFTeKYC.DataDecoder
  public let dataPreprocessor: any VFTeKYC.DataPreprocessor
  public init(decoder: any VFTeKYC.DataDecoder = JSONDecoder(), dataPreprocessor: any VFTeKYC.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : VFTeKYC.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : VFTeKYC.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension VFTeKYC.DataStreamSerializer {
  public static func decodable<T>(of type: T.Type, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), dataPreprocessor: any VFTeKYC.DataPreprocessor = PassthroughPreprocessor()) -> Self where Self == VFTeKYC.DecodableStreamSerializer<T>, T : Swift.Decodable
}
extension VFTeKYC.DataStreamSerializer where Self == VFTeKYC.PassthroughStreamSerializer {
  public static var passthrough: VFTeKYC.PassthroughStreamSerializer {
    get
  }
}
extension VFTeKYC.DataStreamSerializer where Self == VFTeKYC.StringStreamSerializer {
  public static var string: VFTeKYC.StringStreamSerializer {
    get
  }
}
extension VFTeKYC.DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping VFTeKYC.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping VFTeKYC.DataStreamRequest.Handler<Serializer.SerializedObject, VFTeKYC.AFError>) -> Self where Serializer : VFTeKYC.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping VFTeKYC.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: any VFTeKYC.DataDecoder = JSONDecoder(), preprocessor: any VFTeKYC.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping VFTeKYC.DataStreamRequest.Handler<T, VFTeKYC.AFError>) -> Self where T : Swift.Decodable
}
public struct VFTMrzValid : Swift.Codable {
  public let mrzChecksum: Swift.Bool?
  public let mrzIdNumber: Swift.String?
  public let mrzDob: Swift.String?
  public let mrzExpired: Swift.String?
  public let mrzFullname: Swift.String?
  public let mrzGender: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : VFTeKYC.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  #if compiler(>=5.3) && $NonescapableTypes
  func refresh(_ credential: Self.Credential, for session: VFTeKYC.Session, completion: @escaping (Swift.Result<Self.Credential, any Swift.Error>) -> Swift.Void)
  #endif
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: any Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: VFTeKYC.AuthenticationError, b: VFTeKYC.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class AuthenticationInterceptor<AuthenticatorType> : VFTeKYC.RequestInterceptor where AuthenticatorType : VFTeKYC.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var credential: VFTeKYC.AuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(authenticator: AuthenticatorType, credential: VFTeKYC.AuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: VFTeKYC.AuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: VFTeKYC.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  #endif
  public func retry(_ request: VFTeKYC.Request, for session: VFTeKYC.Session, dueTo error: any Swift.Error, completion: @escaping (VFTeKYC.RetryResult) -> Swift.Void)
  @objc deinit
}
extension Foundation.URLSessionConfiguration : VFTeKYC.AlamofireExtended {
  @available(iOS 7.0, *)
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension VFTeKYC.AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
  public static var ephemeral: Foundation.URLSessionConfiguration {
    get
  }
}
@objc @objcMembers public class EFQRCodeRecognizer : ObjectiveC.NSObject {
  @objc public var image: CoreGraphics.CGImage {
    @objc get
    @objc set
  }
  @objc public init(image: CoreGraphics.CGImage)
  @objc public func recognize() -> [Swift.String]
  @objc deinit
}
public struct VFTIdValid : Swift.Codable {
  public let idLength: Swift.Bool?
  public let location: Swift.Bool?
  public let genderCentury: Swift.Bool?
  public let dobYear: Swift.Bool?
  public let expired: Swift.Bool?
  public let dobFormat: Swift.Bool?
  public let isNotEdited: Swift.Bool?
  public let isNotSlided: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension VFTeKYC.Request {
  public static let didResumeNotification: Foundation.Notification.Name
  public static let didSuspendNotification: Foundation.Notification.Name
  public static let didCancelNotification: Foundation.Notification.Name
  public static let didFinishNotification: Foundation.Notification.Name
  public static let didResumeTaskNotification: Foundation.Notification.Name
  public static let didSuspendTaskNotification: Foundation.Notification.Name
  public static let didCancelTaskNotification: Foundation.Notification.Name
  public static let didCompleteTaskNotification: Foundation.Notification.Name
}
extension Foundation.Notification {
  #if compiler(>=5.3) && $NonescapableTypes
  public var request: VFTeKYC.Request? {
    get
  }
  #endif
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : VFTeKYC.EventMonitor {
  final public func requestDidResume(_ request: VFTeKYC.Request)
  final public func requestDidSuspend(_ request: VFTeKYC.Request)
  final public func requestDidCancel(_ request: VFTeKYC.Request)
  final public func requestDidFinish(_ request: VFTeKYC.Request)
  final public func request(_ request: VFTeKYC.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func request(_ request: VFTeKYC.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func request(_ request: VFTeKYC.Request, didCancelTask task: Foundation.URLSessionTask)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func request(_ request: VFTeKYC.Request, didCompleteTask task: Foundation.URLSessionTask, with error: VFTeKYC.AFError?)
  #endif
  @objc deinit
}
open class Session {
  public static let `default`: VFTeKYC.Session
  final public let session: Foundation.URLSession
  final public let delegate: VFTeKYC.SessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: (any VFTeKYC.RequestInterceptor)?
  final public let serverTrustManager: VFTeKYC.ServerTrustManager?
  final public let redirectHandler: (any VFTeKYC.RedirectHandler)?
  final public let cachedResponseHandler: (any VFTeKYC.CachedResponseHandler)?
  final public let eventMonitor: VFTeKYC.CompositeEventMonitor
  final public let defaultEventMonitors: [any VFTeKYC.EventMonitor]
  #if compiler(>=5.3) && $NonescapableTypes
  public init(session: Foundation.URLSession, delegate: VFTeKYC.SessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, serverTrustManager: VFTeKYC.ServerTrustManager? = nil, redirectHandler: (any VFTeKYC.RedirectHandler)? = nil, cachedResponseHandler: (any VFTeKYC.CachedResponseHandler)? = nil, eventMonitors: [any VFTeKYC.EventMonitor] = [])
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: VFTeKYC.SessionDelegate = SessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, serverTrustManager: VFTeKYC.ServerTrustManager? = nil, redirectHandler: (any VFTeKYC.RedirectHandler)? = nil, cachedResponseHandler: (any VFTeKYC.CachedResponseHandler)? = nil, eventMonitors: [any VFTeKYC.EventMonitor] = [])
  #endif
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<VFTeKYC.Request>) -> Swift.Void)
  #if compiler(>=5.3) && $NonescapableTypes
  public func cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  #endif
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  #if compiler(>=5.3) && $NonescapableTypes
  open func request(_ convertible: any VFTeKYC.URLConvertible, method: VFTeKYC.HTTPMethod = .get, parameters: VFTeKYC.Parameters? = nil, encoding: any VFTeKYC.ParameterEncoding = URLEncoding.default, headers: VFTeKYC.HTTPHeaders? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, requestModifier: VFTeKYC.Session.RequestModifier? = nil) -> VFTeKYC.DataRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func request<Parameters>(_ convertible: any VFTeKYC.URLConvertible, method: VFTeKYC.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any VFTeKYC.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: VFTeKYC.HTTPHeaders? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, requestModifier: VFTeKYC.Session.RequestModifier? = nil) -> VFTeKYC.DataRequest where Parameters : Swift.Encodable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func request(_ convertible: any VFTeKYC.URLRequestConvertible, interceptor: (any VFTeKYC.RequestInterceptor)? = nil) -> VFTeKYC.DataRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func streamRequest<Parameters>(_ convertible: any VFTeKYC.URLConvertible, method: VFTeKYC.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any VFTeKYC.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: VFTeKYC.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, requestModifier: VFTeKYC.Session.RequestModifier? = nil) -> VFTeKYC.DataStreamRequest where Parameters : Swift.Encodable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func streamRequest(_ convertible: any VFTeKYC.URLConvertible, method: VFTeKYC.HTTPMethod = .get, headers: VFTeKYC.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, requestModifier: VFTeKYC.Session.RequestModifier? = nil) -> VFTeKYC.DataStreamRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func streamRequest(_ convertible: any VFTeKYC.URLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any VFTeKYC.RequestInterceptor)? = nil) -> VFTeKYC.DataStreamRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func download(_ convertible: any VFTeKYC.URLConvertible, method: VFTeKYC.HTTPMethod = .get, parameters: VFTeKYC.Parameters? = nil, encoding: any VFTeKYC.ParameterEncoding = URLEncoding.default, headers: VFTeKYC.HTTPHeaders? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, requestModifier: VFTeKYC.Session.RequestModifier? = nil, to destination: VFTeKYC.DownloadRequest.Destination? = nil) -> VFTeKYC.DownloadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func download<Parameters>(_ convertible: any VFTeKYC.URLConvertible, method: VFTeKYC.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any VFTeKYC.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: VFTeKYC.HTTPHeaders? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, requestModifier: VFTeKYC.Session.RequestModifier? = nil, to destination: VFTeKYC.DownloadRequest.Destination? = nil) -> VFTeKYC.DownloadRequest where Parameters : Swift.Encodable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func download(_ convertible: any VFTeKYC.URLRequestConvertible, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, to destination: VFTeKYC.DownloadRequest.Destination? = nil) -> VFTeKYC.DownloadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func download(resumingWith data: Foundation.Data, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, to destination: VFTeKYC.DownloadRequest.Destination? = nil) -> VFTeKYC.DownloadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func upload(_ data: Foundation.Data, to convertible: any VFTeKYC.URLConvertible, method: VFTeKYC.HTTPMethod = .post, headers: VFTeKYC.HTTPHeaders? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: VFTeKYC.Session.RequestModifier? = nil) -> VFTeKYC.UploadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func upload(_ data: Foundation.Data, with convertible: any VFTeKYC.URLRequestConvertible, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> VFTeKYC.UploadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func upload(_ fileURL: Foundation.URL, to convertible: any VFTeKYC.URLConvertible, method: VFTeKYC.HTTPMethod = .post, headers: VFTeKYC.HTTPHeaders? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: VFTeKYC.Session.RequestModifier? = nil) -> VFTeKYC.UploadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func upload(_ fileURL: Foundation.URL, with convertible: any VFTeKYC.URLRequestConvertible, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> VFTeKYC.UploadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func upload(_ stream: Foundation.InputStream, to convertible: any VFTeKYC.URLConvertible, method: VFTeKYC.HTTPMethod = .post, headers: VFTeKYC.HTTPHeaders? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: VFTeKYC.Session.RequestModifier? = nil) -> VFTeKYC.UploadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func upload(_ stream: Foundation.InputStream, with convertible: any VFTeKYC.URLRequestConvertible, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> VFTeKYC.UploadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func upload(multipartFormData: @escaping (VFTeKYC.MultipartFormData) -> Swift.Void, to url: any VFTeKYC.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: VFTeKYC.HTTPMethod = .post, headers: VFTeKYC.HTTPHeaders? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: VFTeKYC.Session.RequestModifier? = nil) -> VFTeKYC.UploadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func upload(multipartFormData: @escaping (VFTeKYC.MultipartFormData) -> Swift.Void, with request: any VFTeKYC.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> VFTeKYC.UploadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func upload(multipartFormData: VFTeKYC.MultipartFormData, to url: any VFTeKYC.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: VFTeKYC.HTTPMethod = .post, headers: VFTeKYC.HTTPHeaders? = nil, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: VFTeKYC.Session.RequestModifier? = nil) -> VFTeKYC.UploadRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func upload(multipartFormData: VFTeKYC.MultipartFormData, with request: any VFTeKYC.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: (any VFTeKYC.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> VFTeKYC.UploadRequest
  #endif
}
extension VFTeKYC.Session : VFTeKYC.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after request: VFTeKYC.Request)
  public func retryResult(for request: VFTeKYC.Request, dueTo error: VFTeKYC.AFError, completion: @escaping (VFTeKYC.RetryResult) -> Swift.Void)
  #if compiler(>=5.3) && $NonescapableTypes
  public func retryRequest(_ request: VFTeKYC.Request, withDelay timeDelay: Foundation.TimeInterval?)
  #endif
}
extension UIKit.UIViewController {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func showDialog(title: Swift.String? = "Xc thc cha thnh cng", message: Swift.String, isSucces: Swift.Bool? = false, completion: (() -> Swift.Void)? = nil)
  #endif
}
@_hasMissingDesignatedInitializers public class VFTResult {
  @objc deinit
}
public struct VFTFrontSide : Swift.Codable {
  public let ocrInfo: VFTeKYC.VFTOcrInfo?
  public let cardType: Swift.String?
  public let screenCapValid: VFTeKYC.VFTScreenCapValid?
  public let clippedCornerValid: VFTeKYC.VFTClippedCornerValid?
  public let blurValid: VFTeKYC.VFTBlurValid?
  public let overExposeValid: VFTeKYC.VFTOverExposeValid?
  public let checkFaceStatus: Swift.Bool?
  public let cardOverflowValid: VFTeKYC.VFTCardOverflowValid?
  public let rotateAngle: Swift.Int?
  public let idValid: VFTeKYC.VFTIdValid?
  public let predictMultipleCard: Swift.Bool?
  public let cardAreaPercentValid: VFTeKYC.VFTCardAreaPercentValid?
  public let photocopyValid: VFTeKYC.VFTPhotocopyValid?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTBlurValid : Swift.Codable {
  public let isBlur: Swift.Bool?
  public let ratioDA: Swift.Double?
  public let ratioRG: Swift.Double?
  public let blurScore: Swift.Double?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: VFTeKYC.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: VFTeKYC.AlamofireExtension<Self.ExtendedType> { get set }
}
extension VFTeKYC.AlamofireExtended {
  public static var af: VFTeKYC.AlamofireExtension<Self>.Type {
    get
    set
  }
  public var af: VFTeKYC.AlamofireExtension<Self> {
    get
    set
  }
}
public struct VFTFaceMaskVerify : Swift.Codable {
  public let faceInImage01: Swift.Bool?
  public let faceInImage02: Swift.Bool?
  public let faceInImage03: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension VFTeKYC.EFQRCode {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func generateGIF(using generator: VFTeKYC.EFQRCodeGenerator, withWatermarkGIF data: Foundation.Data, delay: Swift.Double? = nil, loopCount: Swift.Int? = nil, useMultipleThreads: Swift.Bool = false) -> Foundation.Data?
  #endif
}
public struct HTTPHeaders {
  public init()
  public init(_ headers: [VFTeKYC.HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: VFTeKYC.HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: VFTeKYC.HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> VFTeKYC.HTTPHeaders
  #if compiler(>=5.3) && $NonescapableTypes
  public func value(for name: Swift.String) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set
  }
  #endif
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension VFTeKYC.HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension VFTeKYC.HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: VFTeKYC.HTTPHeader...)
  public typealias ArrayLiteralElement = VFTeKYC.HTTPHeader
}
extension VFTeKYC.HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[VFTeKYC.HTTPHeader]>
  public typealias Element = Swift.IndexingIterator<[VFTeKYC.HTTPHeader]>.Element
  public typealias Iterator = Swift.IndexingIterator<[VFTeKYC.HTTPHeader]>
}
extension VFTeKYC.HTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> VFTeKYC.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<VFTeKYC.HTTPHeaders>
  public typealias SubSequence = Swift.Slice<VFTeKYC.HTTPHeaders>
}
extension VFTeKYC.HTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public static func == (a: VFTeKYC.HTTPHeader, b: VFTeKYC.HTTPHeader) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension VFTeKYC.HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension VFTeKYC.HTTPHeader {
  public static func accept(_ value: Swift.String) -> VFTeKYC.HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> VFTeKYC.HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> VFTeKYC.HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> VFTeKYC.HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> VFTeKYC.HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> VFTeKYC.HTTPHeader
  public static func authorization(_ value: Swift.String) -> VFTeKYC.HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> VFTeKYC.HTTPHeader
  public static func contentType(_ value: Swift.String) -> VFTeKYC.HTTPHeader
  public static func userAgent(_ value: Swift.String) -> VFTeKYC.HTTPHeader
}
extension VFTeKYC.HTTPHeaders {
  public static let `default`: VFTeKYC.HTTPHeaders
}
extension VFTeKYC.HTTPHeader {
  public static let defaultAcceptEncoding: VFTeKYC.HTTPHeader
  public static let defaultAcceptLanguage: VFTeKYC.HTTPHeader
  public static let defaultUserAgent: VFTeKYC.HTTPHeader
}
extension Foundation.URLRequest {
  public var headers: VFTeKYC.HTTPHeaders {
    get
    set
  }
}
extension Foundation.HTTPURLResponse {
  public var headers: VFTeKYC.HTTPHeaders {
    get
  }
}
extension Foundation.URLSessionConfiguration {
  public var headers: VFTeKYC.HTTPHeaders {
    get
    set
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class AEOTPTextField : UIKit.UITextField {
  @_Concurrency.MainActor @preconcurrency public var otpDefaultCharacter: Swift.String
  @_Concurrency.MainActor @preconcurrency public var otpBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public var otpFilledBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public var otpCornerRaduis: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var otpDefaultBorderColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public var otpFilledBorderColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public var otpDefaultBorderWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var otpFilledBorderWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var otpTextColor: UIKit.UIColor
  @_Concurrency.MainActor @preconcurrency public var otpFontSize: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var otpFont: UIKit.UIFont
  @_Concurrency.MainActor @preconcurrency weak public var otpDelegate: (any VFTeKYC.AEOTPTextFieldDelegate)?
  @_Concurrency.MainActor @preconcurrency public func configure(with slotCount: Swift.Int = 6)
  @_Concurrency.MainActor @preconcurrency public func clearOTP()
  @_Concurrency.MainActor @preconcurrency public func setText(_ text: Swift.String)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
  @objc deinit
}
public protocol AEOTPTextFieldDelegate : AnyObject {
  func didUserFinishEnter(the code: Swift.String)
}
public enum AFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: any Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: any Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: any Swift.Error)
    case inputStreamReadFailed(error: any Swift.Error)
  }
  public struct UnexpectedInputStreamLength : Swift.Error {
    public var bytesExpected: Swift.UInt64
    public var bytesRead: Swift.UInt64
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: any Swift.Error)
    case customEncodingFailed(error: any Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(VFTeKYC.AFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: any Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: any Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: any Swift.Error)
    case decodingFailed(error: any Swift.Error)
    case customSerializationFailed(error: any Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: (any Swift.Error)?)
    case defaultEvaluationFailed(output: VFTeKYC.AFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: VFTeKYC.AFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: VFTeKYC.AFError.ServerTrustFailureReason.Output, options: VFTeKYC.RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: any Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: any Swift.Error)
  case createURLRequestFailed(error: any Swift.Error)
  case downloadedFileMoveFailed(error: any Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: any VFTeKYC.URLConvertible)
  case multipartEncodingFailed(reason: VFTeKYC.AFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: VFTeKYC.AFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: VFTeKYC.AFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: any Swift.Error)
  case requestRetryFailed(retryError: any Swift.Error, originalError: any Swift.Error)
  case responseValidationFailed(reason: VFTeKYC.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: VFTeKYC.AFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: VFTeKYC.AFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: (any Swift.Error)?)
  case sessionTaskFailed(error: any Swift.Error)
  case urlRequestValidationFailed(reason: VFTeKYC.AFError.URLRequestValidationFailureReason)
}
extension Swift.Error {
  #if compiler(>=5.3) && $NonescapableTypes
  public var asAFError: VFTeKYC.AFError? {
    get
  }
  #endif
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> VFTeKYC.AFError
}
extension VFTeKYC.AFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension VFTeKYC.AFError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var urlConvertible: (any VFTeKYC.URLConvertible)? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var url: Foundation.URL? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var underlyingError: (any Swift.Error)? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var responseContentType: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var responseCode: Swift.Int? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var sourceURL: Foundation.URL? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var destinationURL: Foundation.URL? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var downloadResumeData: Foundation.Data? {
    get
  }
  #endif
}
extension VFTeKYC.AFError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  #if compiler(>=5.3) && $NonescapableTypes
  func encode(_ urlRequest: any VFTeKYC.URLRequestConvertible, with parameters: VFTeKYC.Parameters?) throws -> Foundation.URLRequest
  #endif
}
public struct URLEncoding : VFTeKYC.ParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: VFTeKYC.URLEncoding.Destination, b: VFTeKYC.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: VFTeKYC.URLEncoding.ArrayEncoding, b: VFTeKYC.URLEncoding.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: VFTeKYC.URLEncoding.BoolEncoding, b: VFTeKYC.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: VFTeKYC.URLEncoding {
    get
  }
  public static var queryString: VFTeKYC.URLEncoding {
    get
  }
  public static var httpBody: VFTeKYC.URLEncoding {
    get
  }
  public let destination: VFTeKYC.URLEncoding.Destination
  public let arrayEncoding: VFTeKYC.URLEncoding.ArrayEncoding
  public let boolEncoding: VFTeKYC.URLEncoding.BoolEncoding
  public init(destination: VFTeKYC.URLEncoding.Destination = .methodDependent, arrayEncoding: VFTeKYC.URLEncoding.ArrayEncoding = .brackets, boolEncoding: VFTeKYC.URLEncoding.BoolEncoding = .numeric)
  #if compiler(>=5.3) && $NonescapableTypes
  public func encode(_ urlRequest: any VFTeKYC.URLRequestConvertible, with parameters: VFTeKYC.Parameters?) throws -> Foundation.URLRequest
  #endif
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : VFTeKYC.ParameterEncoding {
  public enum Error : Swift.Error {
    case invalidJSONObject
    public static func == (a: VFTeKYC.JSONEncoding.Error, b: VFTeKYC.JSONEncoding.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: VFTeKYC.JSONEncoding {
    get
  }
  public static var prettyPrinted: VFTeKYC.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  #if compiler(>=5.3) && $NonescapableTypes
  public func encode(_ urlRequest: any VFTeKYC.URLRequestConvertible, with parameters: VFTeKYC.Parameters?) throws -> Foundation.URLRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func encode(_ urlRequest: any VFTeKYC.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
  #endif
}
extension VFTeKYC.JSONEncoding.Error {
  public var localizedDescription: Swift.String {
    get
  }
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension Swift.String : VFTeKYC.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URL : VFTeKYC.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : VFTeKYC.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension VFTeKYC.URLRequestConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  public var urlRequest: Foundation.URLRequest? {
    get
  }
  #endif
}
extension Foundation.URLRequest : VFTeKYC.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension Foundation.URLRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(url: any VFTeKYC.URLConvertible, method: VFTeKYC.HTTPMethod, headers: VFTeKYC.HTTPHeaders? = nil) throws
  #endif
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class LoginVC : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
  @objc deinit
}
public struct ReadIDResponse : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ChipCardInfo : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
open class RetryPolicy : VFTeKYC.RequestInterceptor {
  public static let defaultRetryLimit: Swift.UInt
  public static let defaultExponentialBackoffBase: Swift.UInt
  public static let defaultExponentialBackoffScale: Swift.Double
  public static let defaultRetryableHTTPMethods: Swift.Set<VFTeKYC.HTTPMethod>
  public static let defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static let defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<VFTeKYC.HTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<VFTeKYC.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ request: VFTeKYC.Request, for session: VFTeKYC.Session, dueTo error: any Swift.Error, completion: @escaping (VFTeKYC.RetryResult) -> Swift.Void)
  open func shouldRetry(request: VFTeKYC.Request, dueTo error: any Swift.Error) -> Swift.Bool
  @objc deinit
}
extension VFTeKYC.RequestInterceptor where Self == VFTeKYC.RetryPolicy {
  public static var retryPolicy: VFTeKYC.RetryPolicy {
    get
  }
  public static func retryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<VFTeKYC.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes) -> VFTeKYC.RetryPolicy
}
open class ConnectionLostRetryPolicy : VFTeKYC.RetryPolicy {
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<VFTeKYC.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods)
  @objc deinit
}
extension VFTeKYC.RequestInterceptor where Self == VFTeKYC.ConnectionLostRetryPolicy {
  public static var connectionLostRetryPolicy: VFTeKYC.ConnectionLostRetryPolicy {
    get
  }
  public static func connectionLostRetryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<VFTeKYC.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods) -> VFTeKYC.ConnectionLostRetryPolicy
}
public struct VFTCardAreaPercentValid : Swift.Codable {
  public let isNotQualityCardImg: Swift.Bool?
  public let cardAreaPercentWithImage: Swift.Double?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension VFTeKYC.Request {
  public func uploadProgress(bufferingPolicy: VFTeKYC.StreamOf<Foundation.Progress>.BufferingPolicy = .unbounded) -> VFTeKYC.StreamOf<Foundation.Progress>
  public func downloadProgress(bufferingPolicy: VFTeKYC.StreamOf<Foundation.Progress>.BufferingPolicy = .unbounded) -> VFTeKYC.StreamOf<Foundation.Progress>
  public func urlRequests(bufferingPolicy: VFTeKYC.StreamOf<Foundation.URLRequest>.BufferingPolicy = .unbounded) -> VFTeKYC.StreamOf<Foundation.URLRequest>
  public func urlSessionTasks(bufferingPolicy: VFTeKYC.StreamOf<Foundation.URLSessionTask>.BufferingPolicy = .unbounded) -> VFTeKYC.StreamOf<Foundation.URLSessionTask>
  public func cURLDescriptions(bufferingPolicy: VFTeKYC.StreamOf<Swift.String>.BufferingPolicy = .unbounded) -> VFTeKYC.StreamOf<Swift.String>
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DataTask<Value> {
  public var response: VFTeKYC.DataResponse<Value, VFTeKYC.AFError> {
    get async
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var result: Swift.Result<Value, VFTeKYC.AFError> {
    get async
  }
  #endif
  public var value: Value {
    get async throws
  }
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension VFTeKYC.DataRequest {
  public func serializingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any VFTeKYC.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> VFTeKYC.DataTask<Foundation.Data>
  public func serializingDecodable<Value>(_ type: Value.Type = Value.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any VFTeKYC.DataPreprocessor = DecodableResponseSerializer<Value>.defaultDataPreprocessor, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<Value>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DecodableResponseSerializer<Value>.defaultEmptyRequestMethods) -> VFTeKYC.DataTask<Value> where Value : Swift.Decodable
  #if compiler(>=5.3) && $NonescapableTypes
  public func serializingString(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any VFTeKYC.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> VFTeKYC.DataTask<Swift.String>
  #endif
  public func serializingResponse<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> VFTeKYC.DataTask<Serializer.SerializedObject> where Serializer : VFTeKYC.ResponseSerializer
  public func serializingResponse<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> VFTeKYC.DataTask<Serializer.SerializedObject> where Serializer : VFTeKYC.DataResponseSerializerProtocol
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DownloadTask<Value> {
  public var response: VFTeKYC.DownloadResponse<Value, VFTeKYC.AFError> {
    get async
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var result: Swift.Result<Value, VFTeKYC.AFError> {
    get async
  }
  #endif
  public var value: Value {
    get async throws
  }
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension VFTeKYC.DownloadRequest {
  public func serializingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any VFTeKYC.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> VFTeKYC.DownloadTask<Foundation.Data>
  public func serializingDecodable<Value>(_ type: Value.Type = Value.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any VFTeKYC.DataPreprocessor = DecodableResponseSerializer<Value>.defaultDataPreprocessor, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<Value>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DecodableResponseSerializer<Value>.defaultEmptyRequestMethods) -> VFTeKYC.DownloadTask<Value> where Value : Swift.Decodable
  public func serializingDownloadedFileURL(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> VFTeKYC.DownloadTask<Foundation.URL>
  #if compiler(>=5.3) && $NonescapableTypes
  public func serializingString(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any VFTeKYC.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> VFTeKYC.DownloadTask<Swift.String>
  #endif
  public func serializingDownload<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> VFTeKYC.DownloadTask<Serializer.SerializedObject> where Serializer : VFTeKYC.ResponseSerializer
  public func serializingDownload<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> VFTeKYC.DownloadTask<Serializer.SerializedObject> where Serializer : VFTeKYC.DownloadResponseSerializerProtocol
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DataStreamTask {
  public typealias Stream<Success, Failure> = VFTeKYC.StreamOf<VFTeKYC.DataStreamRequest.Stream<Success, Failure>> where Failure : Swift.Error
  public func streamingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: VFTeKYC.DataStreamTask.Stream<Foundation.Data, Swift.Never>.BufferingPolicy = .unbounded) -> VFTeKYC.DataStreamTask.Stream<Foundation.Data, Swift.Never>
  public func streamingStrings(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: VFTeKYC.DataStreamTask.Stream<Swift.String, Swift.Never>.BufferingPolicy = .unbounded) -> VFTeKYC.DataStreamTask.Stream<Swift.String, Swift.Never>
  public func streamingDecodables<T>(_ type: T.Type = T.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: VFTeKYC.DataStreamTask.Stream<T, VFTeKYC.AFError>.BufferingPolicy = .unbounded) -> VFTeKYC.DataStreamTask.Stream<T, VFTeKYC.AFError> where T : Swift.Decodable
  public func streamingResponses<Serializer>(serializedUsing serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: VFTeKYC.DataStreamTask.Stream<Serializer.SerializedObject, VFTeKYC.AFError>.BufferingPolicy = .unbounded) -> VFTeKYC.DataStreamTask.Stream<Serializer.SerializedObject, VFTeKYC.AFError> where Serializer : VFTeKYC.DataStreamSerializer
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension VFTeKYC.DataStreamRequest {
  final public func streamTask() -> VFTeKYC.DataStreamTask
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct StreamOf<Element> : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = VFTeKYC.StreamOf<Element>.Iterator
  public typealias BufferingPolicy = _Concurrency.AsyncStream<Element>.Continuation.BufferingPolicy
  public func makeAsyncIterator() -> VFTeKYC.StreamOf<Element>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $NonescapableTypes
    public mutating func next() async -> Element?
    #endif
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
}
extension CoreGraphics.CGColor {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func white(_ white: CoreFoundation.CGFloat = 1.0, alpha: CoreFoundation.CGFloat = 1.0) -> CoreGraphics.CGColor?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func black(_ black: CoreFoundation.CGFloat = 1.0, alpha: CoreFoundation.CGFloat = 1.0) -> CoreGraphics.CGColor?
  #endif
}
extension VFTeKYC.EFQRCodeGenerator {
  @objc @available(swift, obsoleted: 1.0)
  convenience dynamic public init(content: Swift.String, encoding: Swift.UInt, size: VFTeKYC.EFIntSize)
  @objc @discardableResult
  @available(swift, obsoleted: 1.0)
  dynamic public func withContent(_ content: Swift.String, encoding: Swift.UInt) -> VFTeKYC.EFQRCodeGenerator
  @objc @discardableResult
  @available(swift, obsoleted: 1.0, renamed: "withMode")
  dynamic public func withNormalMode() -> VFTeKYC.EFQRCodeGenerator
  @objc @discardableResult
  @available(swift, obsoleted: 1.0, renamed: "withMode")
  dynamic public func withGrayscaleMode() -> VFTeKYC.EFQRCodeGenerator
  @objc @discardableResult
  @available(swift, obsoleted: 1.0, renamed: "withMode")
  dynamic public func withBinarizationMode(threshold: CoreFoundation.CGFloat) -> VFTeKYC.EFQRCodeGenerator
  @objc @discardableResult
  @available(swift, obsoleted: 1.0)
  dynamic public func withWatermark(_ watermark: CoreGraphics.CGImage, mode: VFTeKYC.EFWatermarkMode) -> VFTeKYC.EFQRCodeGenerator
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(swift, obsoleted: 1.0)
  dynamic public func generateGIF(watermarkGIF data: Foundation.Data) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(swift, obsoleted: 1.0)
  dynamic public func generateGIF(watermarkGIF data: Foundation.Data, delay: Swift.Double, loopCount: Swift.Int, useMultipleThreads: Swift.Bool) -> Foundation.Data?
  #endif
}
public typealias AFDataResponse<Success> = VFTeKYC.DataResponse<Success, VFTeKYC.AFError>
public typealias AFDownloadResponse<Success> = VFTeKYC.DownloadResponse<Success, VFTeKYC.AFError>
public struct DataResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  #if compiler(>=5.3) && $NonescapableTypes
  public var value: Success? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var error: Failure? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
  #endif
}
extension VFTeKYC.DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension VFTeKYC.DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> VFTeKYC.DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> VFTeKYC.DataResponse<NewSuccess, any Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> VFTeKYC.DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> VFTeKYC.DataResponse<Success, any Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  #if compiler(>=5.3) && $NonescapableTypes
  public var value: Success? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var error: Failure? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
  #endif
}
extension VFTeKYC.DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension VFTeKYC.DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> VFTeKYC.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> VFTeKYC.DownloadResponse<NewSuccess, any Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> VFTeKYC.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> VFTeKYC.DownloadResponse<Success, any Swift.Error> where NewFailure : Swift.Error
}
@objc @objcMembers public class EFQRCodeGenerator : ObjectiveC.NSObject {
  @discardableResult
  @inlinable public func with<T>(_ keyPath: Swift.ReferenceWritableKeyPath<VFTeKYC.EFQRCodeGenerator, T>, _ newValue: T) -> VFTeKYC.EFQRCodeGenerator {
        self[keyPath: keyPath] = newValue
        return self
    }
  @objc public var content: Swift.String? {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func withContent(_ content: Swift.String, encoding: Swift.String.Encoding? = nil) -> VFTeKYC.EFQRCodeGenerator
  #endif
  public var contentEncoding: Swift.String.Encoding {
    get
    set
  }
  @discardableResult
  public func withContentEncoding(_ encoding: Swift.String.Encoding) -> VFTeKYC.EFQRCodeGenerator
  @objc public var inputCorrectionLevel: VFTeKYC.EFInputCorrectionLevel {
    @objc get
    @objc set
  }
  @objc @discardableResult
  public func withInputCorrectionLevel(_ inputCorrectionLevel: VFTeKYC.EFInputCorrectionLevel) -> VFTeKYC.EFQRCodeGenerator
  public var mode: VFTeKYC.EFQRCodeMode? {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func withMode(_ mode: VFTeKYC.EFQRCodeMode?) -> VFTeKYC.EFQRCodeGenerator
  #endif
  @objc public var size: VFTeKYC.EFIntSize {
    @objc get
    @objc set
  }
  @objc @discardableResult
  public func withSize(_ size: VFTeKYC.EFIntSize) -> VFTeKYC.EFQRCodeGenerator
  @objc public var magnification: VFTeKYC.EFIntSize? {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @discardableResult
  public func withMagnification(_ magnification: VFTeKYC.EFIntSize?) -> VFTeKYC.EFQRCodeGenerator
  #endif
  @objc public var backgroundColor: CoreGraphics.CGColor {
    @objc get
    @objc set
  }
  @objc public var foregroundColor: CoreGraphics.CGColor {
    @objc get
    @objc set
  }
  @discardableResult
  @objc(withCIColorsForBackgroundColor:foregroundColor:) public func withColors(backgroundColor: CoreImage.CIColor, foregroundColor: CoreImage.CIColor) -> VFTeKYC.EFQRCodeGenerator
  @discardableResult
  @objc(withCGColorsForBackgroundColor:foregroundColor:) public func withColors(backgroundColor: CoreGraphics.CGColor, foregroundColor: CoreGraphics.CGColor) -> VFTeKYC.EFQRCodeGenerator
  @objc public var icon: CoreGraphics.CGImage? {
    @objc get
    @objc set
  }
  @objc public var iconSize: VFTeKYC.EFIntSize? {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @discardableResult
  public func withIcon(_ icon: CoreGraphics.CGImage?, size: VFTeKYC.EFIntSize?) -> VFTeKYC.EFQRCodeGenerator
  #endif
  @objc public var watermark: CoreGraphics.CGImage? {
    @objc get
    @objc set
  }
  @objc public var watermarkMode: VFTeKYC.EFWatermarkMode {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func withWatermark(_ watermark: CoreGraphics.CGImage?, mode: VFTeKYC.EFWatermarkMode? = nil) -> VFTeKYC.EFQRCodeGenerator
  #endif
  @objc public var pointOffset: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @discardableResult
  public func withPointOffset(_ pointOffset: CoreFoundation.CGFloat) -> VFTeKYC.EFQRCodeGenerator
  @objc public var isWatermarkOpaque: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @discardableResult
  public func withOpaqueWatermark(_ isWatermarkOpaque: Swift.Bool = true) -> VFTeKYC.EFQRCodeGenerator
  @objc @discardableResult
  public func withTransparentWatermark(_ isTransparent: Swift.Bool = true) -> VFTeKYC.EFQRCodeGenerator
  @objc public var pointStyle: any VFTeKYC.EFPointStyle {
    @objc get
    @objc set
  }
  @objc @discardableResult
  public func withPointStyle(_ pointStyle: any VFTeKYC.EFPointStyle) -> VFTeKYC.EFQRCodeGenerator
  @objc public var isTimingPointStatic: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @discardableResult
  public func withStaticTimingPoint(_ isStatic: Swift.Bool = true) -> VFTeKYC.EFQRCodeGenerator
  @objc @discardableResult
  public func withStyledTimingPoint(_ ignoreTiming: Swift.Bool = true) -> VFTeKYC.EFQRCodeGenerator
  @objc public func clearCache()
  public init(content: Swift.String, encoding: Swift.String.Encoding = .utf8, size: VFTeKYC.EFIntSize = EFIntSize(width: 256, height: 256))
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public func generate() -> CoreGraphics.CGImage?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func minMagnification(greaterThanOrEqualTo size: CoreFoundation.CGFloat) -> Swift.Int?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func maxMagnification(lessThanOrEqualTo size: CoreFoundation.CGFloat) -> Swift.Int?
  #endif
  @objc deinit
}
extension VFTeKYC.EFQRCode {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "generate(for:encoding:size:backgroundColor:foregroundColor:watermark:watermarkMode:inputCorrectionLevel:icon:iconSize:watermarkIsTransparent:pointShape:mode:magnification:pointOffset:)")
  public static func generate(content: Swift.String, contentEncoding: Swift.String.Encoding = .utf8, size: VFTeKYC.EFIntSize = EFIntSize(width: 600, height: 600), backgroundColor: CoreGraphics.CGColor = CGColor.white()!, foregroundColor: CoreGraphics.CGColor = CGColor.black()!, watermark: CoreGraphics.CGImage? = nil, watermarkMode: VFTeKYC.EFWatermarkMode = .scaleAspectFill, inputCorrectionLevel: VFTeKYC.EFInputCorrectionLevel = .h, icon: CoreGraphics.CGImage? = nil, iconSize: VFTeKYC.EFIntSize? = nil, allowTransparent: Swift.Bool = true, pointShape: VFTeKYC.EFPointShape = .square, mode: VFTeKYC.EFQRCodeMode = .none, magnification: VFTeKYC.EFIntSize? = nil, foregroundPointOffset: CoreFoundation.CGFloat = 0) -> CoreGraphics.CGImage?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "generateGIF(for:encoding:size:backgroundColor:foregroundColor:watermark:watermarkMode:inputCorrectionLevel:icon:iconSize:watermarkIsTransparent:pointShape:mode:magnification:pointOffset:)")
  public static func generateWithGIF(content: Swift.String, contentEncoding: Swift.String.Encoding = .utf8, size: VFTeKYC.EFIntSize = EFIntSize(width: 600, height: 600), backgroundColor: CoreGraphics.CGColor = CGColor.white()!, foregroundColor: CoreGraphics.CGColor = CGColor.black()!, watermark: Foundation.Data, watermarkMode: VFTeKYC.EFWatermarkMode = .scaleAspectFill, inputCorrectionLevel: VFTeKYC.EFInputCorrectionLevel = .h, icon: CoreGraphics.CGImage? = nil, iconSize: VFTeKYC.EFIntSize? = nil, allowTransparent: Swift.Bool = true, pointShape: VFTeKYC.EFPointShape = .square, mode: VFTeKYC.EFQRCodeMode = .none, magnification: VFTeKYC.EFIntSize? = nil, foregroundPointOffset: CoreFoundation.CGFloat = 0) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "generate(for:encoding:inputCorrectionLevel:size:magnification:backgroundColor:foregroundColor:watermark:watermarkMode:watermarkIsTransparent:icon:iconSize:pointStyle:pointOffset:isTimingPointStyled:mode:)")
  public static func generate(for content: Swift.String, encoding: Swift.String.Encoding = .utf8, inputCorrectionLevel: VFTeKYC.EFInputCorrectionLevel = .h, size: VFTeKYC.EFIntSize = EFIntSize(width: 600, height: 600), magnification: VFTeKYC.EFIntSize? = nil, backgroundColor: CoreGraphics.CGColor = .white()!, foregroundColor: CoreGraphics.CGColor = .black()!, watermark: CoreGraphics.CGImage? = nil, watermarkMode: VFTeKYC.EFWatermarkMode = .scaleAspectFill, watermarkIsTransparent isWatermarkTransparent: Swift.Bool = true, icon: CoreGraphics.CGImage? = nil, iconSize: VFTeKYC.EFIntSize? = nil, pointShape: VFTeKYC.EFPointShape, pointOffset: CoreFoundation.CGFloat = 0, isTimingPointStyled: Swift.Bool = false, mode: VFTeKYC.EFQRCodeMode? = nil) -> CoreGraphics.CGImage?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "generateGIF(for:encoding:inputCorrectionLevel:size:magnification:backgroundColor:foregroundColor:watermark:watermarkMode:watermarkIsTransparent:icon:iconSize:pointStyle:pointOffset:isTimingPointStyled:mode:)")
  public static func generateGIF(for content: Swift.String, encoding: Swift.String.Encoding = .utf8, inputCorrectionLevel: VFTeKYC.EFInputCorrectionLevel = .h, size: VFTeKYC.EFIntSize = EFIntSize(width: 600, height: 600), magnification: VFTeKYC.EFIntSize? = nil, backgroundColor: CoreGraphics.CGColor = .white()!, foregroundColor: CoreGraphics.CGColor = .black()!, watermark: Foundation.Data, watermarkMode: VFTeKYC.EFWatermarkMode = .scaleAspectFill, watermarkIsTransparent isWatermarkTransparent: Swift.Bool = true, icon: CoreGraphics.CGImage? = nil, iconSize: VFTeKYC.EFIntSize? = nil, pointShape: VFTeKYC.EFPointShape, pointOffset: CoreFoundation.CGFloat = 0, isTimingPointStyled: Swift.Bool = false, mode: VFTeKYC.EFQRCodeMode? = nil) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "generateGIF(withWatermarkGIF:using:savingTo:delay:loopCount:useMultipleThreads:)")
  public static func generateWithGIF(data: Foundation.Data, generator: VFTeKYC.EFQRCodeGenerator, pathToSave: Foundation.URL? = nil, delay: Swift.Double? = nil, loopCount: Swift.Int? = nil, useMultipleThread: Swift.Bool = false) -> Foundation.Data?
  #endif
}
extension VFTeKYC.EFQRCodeGenerator {
  @objc @available(*, deprecated, renamed: "withContent(_:)")
  dynamic public func setContent(content: Swift.String)
  @available(*, deprecated, renamed: "withContentEncoding(_:)")
  public func setContentEncoding(encoding: Swift.String.Encoding)
  @available(*, deprecated, renamed: "withMode(_:)")
  public func setMode(mode: VFTeKYC.EFQRCodeMode)
  @objc @available(*, deprecated, renamed: "withInputCorrectionLevel(_:)")
  dynamic public func setInputCorrectionLevel(inputCorrectionLevel: VFTeKYC.EFInputCorrectionLevel)
  @objc @available(*, deprecated, renamed: "withSize(_:)")
  dynamic public func setSize(size: VFTeKYC.EFIntSize)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated, renamed: "withMagnification(_:)")
  dynamic public func setMagnification(magnification: VFTeKYC.EFIntSize?)
  #endif
  @objc @available(*, deprecated, renamed: "withColors(backgroundColor:foregroundColor:)")
  dynamic public func setColors(backgroundColor: CoreGraphics.CGColor, foregroundColor: CoreGraphics.CGColor)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated, renamed: "withIcon(_:size:)")
  dynamic public func setIcon(icon: CoreGraphics.CGImage?, size: VFTeKYC.EFIntSize?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "withWatermark(_:mode:)")
  public func setWatermark(watermark: CoreGraphics.CGImage?, mode: VFTeKYC.EFWatermarkMode? = nil)
  #endif
  @objc @available(*, deprecated, renamed: "withPointOffset(_:)")
  dynamic public func setForegroundPointOffset(foregroundPointOffset: CoreFoundation.CGFloat)
  @objc @available(*, deprecated, renamed: "withTransparentWatermark(_:)")
  dynamic public func setAllowTransparent(allowTransparent: Swift.Bool)
  @objc @available(*, deprecated, renamed: "withPointShape(_:)")
  dynamic public func setPointShape(pointShape: VFTeKYC.EFPointShape)
  @objc @available(*, deprecated, renamed: "withStyledTimingPoint(_:)")
  dynamic public func setIgnoreTiming(ignoreTiming isTimingStyled: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "minMagnification(greaterThanOrEqualTo:)")
  public func minMagnificationGreaterThanOrEqualTo(size: CoreFoundation.CGFloat) -> Swift.Int?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "maxMagnification(lessThanOrEqualTo:)")
  public func maxMagnificationLessThanOrEqualTo(size: CoreFoundation.CGFloat) -> Swift.Int?
  #endif
}
extension VFTeKYC.EFQRCode {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "recognize(_:)")
  public static func recognize(image: CoreGraphics.CGImage?) -> [Swift.String]?
  #endif
}
extension VFTeKYC.EFQRCodeRecognizer {
  @objc @available(*, deprecated, message: "Set `image` property directly.")
  dynamic public func setImage(image: CoreGraphics.CGImage)
}
extension VFTeKYC.EFQRCodeGenerator {
  @available(*, deprecated, renamed: "withColors(backgroundColor:foregroundColor:)")
  @nonobjc public func setColors(backgroundColor: CoreImage.CIColor, foregroundColor: CoreImage.CIColor)
}
@available(*, deprecated, message: "Use EFPointStyle instead.")
@objc public enum EFPointShape : Swift.Int {
  case square = 0
  case circle = 1
  case diamond = 2
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  @available(*, deprecated, message: "Use EFPointStyle instead.")
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension VFTeKYC.EFQRCodeGenerator {
  @objc @available(*, deprecated, renamed: "pointStyle")
  dynamic public var pointShape: VFTeKYC.EFPointShape {
    @objc get
    @objc set
  }
  @objc @available(*, deprecated, renamed: "withPointStyle(_:)")
  @discardableResult
  dynamic public func withPointShape(_ pointShape: VFTeKYC.EFPointShape) -> VFTeKYC.EFQRCodeGenerator
}
public enum VFTSanityForgeryError {
  case blurValid
  case overExposeValid
  case screenCapValid
  case clippedCornerValid
  case cardOverflowValid
  case checkFaceStatus
  case rotateAngle
  case idValid
  public static func == (a: VFTeKYC.VFTSanityForgeryError, b: VFTeKYC.VFTSanityForgeryError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URLRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public var method: VFTeKYC.HTTPMethod? {
    get
    set
  }
  #endif
  public func validate() throws
}
@_hasMissingDesignatedInitializers public class Request {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: VFTeKYC.Request.State, b: VFTeKYC.Request.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: (any VFTeKYC.EventMonitor)?
  final public let interceptor: (any VFTeKYC.RequestInterceptor)?
  weak public var delegate: (any VFTeKYC.RequestDelegate)? {
    get
  }
  public var state: VFTeKYC.Request.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  #if compiler(>=5.3) && $NonescapableTypes
  public var redirectHandler: (any VFTeKYC.RedirectHandler)? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var cachedResponseHandler: (any VFTeKYC.CachedResponseHandler)? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var credential: Foundation.URLCredential? {
    get
  }
  #endif
  public var requests: [Foundation.URLRequest] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var request: Foundation.URLRequest? {
    get
  }
  #endif
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  #endif
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var task: Foundation.URLSessionTask? {
    get
  }
  #endif
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  #endif
  public var retryCount: Swift.Int {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var error: VFTeKYC.AFError? {
    get
  }
  #endif
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping VFTeKYC.Request.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping VFTeKYC.Request.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: any VFTeKYC.RedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: any VFTeKYC.CachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension VFTeKYC.Request : Swift.Equatable {
  public static func == (lhs: VFTeKYC.Request, rhs: VFTeKYC.Request) -> Swift.Bool
}
extension VFTeKYC.Request : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension VFTeKYC.Request : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension VFTeKYC.Request {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after request: VFTeKYC.Request)
  func retryResult(for request: VFTeKYC.Request, dueTo error: VFTeKYC.AFError, completion: @escaping (VFTeKYC.RetryResult) -> Swift.Void)
  #if compiler(>=5.3) && $NonescapableTypes
  func retryRequest(_ request: VFTeKYC.Request, withDelay timeDelay: Foundation.TimeInterval?)
  #endif
}
@_hasMissingDesignatedInitializers public class DataRequest : VFTeKYC.Request {
  final public let convertible: any VFTeKYC.URLRequestConvertible
  #if compiler(>=5.3) && $NonescapableTypes
  public var data: Foundation.Data? {
    get
  }
  #endif
  @discardableResult
  public func validate(_ validation: @escaping VFTeKYC.DataRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : VFTeKYC.Request {
  public typealias Handler<Success, Failure> = (VFTeKYC.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: VFTeKYC.DataStreamRequest.Event<Success, Failure>
    public let token: VFTeKYC.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(VFTeKYC.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: VFTeKYC.AFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: any VFTeKYC.URLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping VFTeKYC.DataStreamRequest.Validation) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  #endif
  @objc deinit
}
extension VFTeKYC.DataStreamRequest.Stream {
  #if compiler(>=5.3) && $NonescapableTypes
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var value: Success? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var error: Failure? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var completion: VFTeKYC.DataStreamRequest.Completion? {
    get
  }
  #endif
}
@_hasMissingDesignatedInitializers public class DownloadRequest : VFTeKYC.Request {
  public struct Options : Swift.OptionSet {
    public static let createIntermediateDirectories: VFTeKYC.DownloadRequest.Options
    public static let removePreviousFile: VFTeKYC.DownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = VFTeKYC.DownloadRequest.Options
    public typealias Element = VFTeKYC.DownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (_ temporaryURL: Foundation.URL, _ response: Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: VFTeKYC.DownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: VFTeKYC.DownloadRequest.Options = []) -> VFTeKYC.DownloadRequest.Destination
  public enum Downloadable {
    case request(any VFTeKYC.URLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var resumeData: Foundation.Data? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var fileURL: Foundation.URL? {
    get
  }
  #endif
  final public let downloadable: VFTeKYC.DownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (_ data: Foundation.Data?) -> Swift.Void) -> Self
  #endif
  @discardableResult
  public func validate(_ validation: @escaping VFTeKYC.DownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UploadRequest : VFTeKYC.DataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let upload: any VFTeKYC.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: VFTeKYC.UploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> VFTeKYC.UploadRequest.Uploadable
}
extension VFTeKYC.UploadRequest.Uploadable : VFTeKYC.UploadableConvertible {
  public func createUploadable() throws -> VFTeKYC.UploadRequest.Uploadable
}
public protocol UploadConvertible : VFTeKYC.URLRequestConvertible, VFTeKYC.UploadableConvertible {
}
extension VFTeKYC.Request {
  public typealias ValidationResult = Swift.Result<Swift.Void, any Swift.Error>
}
extension VFTeKYC.DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> VFTeKYC.DataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension VFTeKYC.DataStreamRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse) -> VFTeKYC.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension VFTeKYC.DownloadRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse, _ fileURL: Foundation.URL?) -> VFTeKYC.DownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
public protocol HKProgressHUDDelegate {
  func hudWasHidden(_ hud: VFTeKYC.HKProgressHUD)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class HKProgressHUD : UIKit.UIView {
  public enum HudMode {
    case indeterminate, determinate, determinateHorizontalBar, annularDeterminate, customView, text
    public static func == (a: VFTeKYC.HKProgressHUD.HudMode, b: VFTeKYC.HKProgressHUD.HudMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum HudAnimation {
    case fade, zoom, zoomOut, zoomIn
    public static func == (a: VFTeKYC.HKProgressHUD.HudAnimation, b: VFTeKYC.HKProgressHUD.HudAnimation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public static let maxOffset: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var progress: Swift.Float {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var progressObject: Foundation.Progress? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var bezelView: VFTeKYC.ProgressHUDBackgroundView?
  @_Concurrency.MainActor @preconcurrency public var backgroundView: VFTeKYC.ProgressHUDBackgroundView?
  @_Concurrency.MainActor @preconcurrency public var customView: UIKit.UIView? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var label: UIKit.UILabel?
  @_Concurrency.MainActor @preconcurrency public var detailsLabel: UIKit.UILabel?
  @_Concurrency.MainActor @preconcurrency public var button: UIKit.UIButton?
  @_Concurrency.MainActor @preconcurrency public var removeFromSuperViewOnHide: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var mode: VFTeKYC.HKProgressHUD.HudMode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var contentColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationType: VFTeKYC.HKProgressHUD.HudAnimation
  @_Concurrency.MainActor @preconcurrency public var offset: CoreFoundation.CGPoint
  @_Concurrency.MainActor @preconcurrency public var margin: CoreFoundation.CGFloat
  @_Concurrency.MainActor @preconcurrency public var minSize: CoreFoundation.CGSize
  @_Concurrency.MainActor @preconcurrency public var isSquare: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var isDefaultMotionEffectsEnabled: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var minShowTime: Swift.Double
  @_Concurrency.MainActor @preconcurrency public var completionBlock: (() -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var delegate: (any VFTeKYC.HKProgressHUDDelegate)?
  @_Concurrency.MainActor @preconcurrency public var graceTime: Swift.Double
  @_Concurrency.MainActor @preconcurrency public class func show(addedToView view: UIKit.UIView, animated: Swift.Bool) -> VFTeKYC.HKProgressHUD
  @_Concurrency.MainActor @preconcurrency public class func hide(addedToView view: UIKit.UIView, animated: Swift.Bool) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public class func hudForView(_ view: UIKit.UIView) -> VFTeKYC.HKProgressHUD?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  #endif
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func updateConstraints()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class ProgressHUDBackgroundView : UIKit.UIView {
  public enum BackgroundStyle {
    case solidColor, blur
    public static func == (a: VFTeKYC.ProgressHUDBackgroundView.BackgroundStyle, b: VFTeKYC.ProgressHUDBackgroundView.BackgroundStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var style: VFTeKYC.ProgressHUDBackgroundView.BackgroundStyle? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var color: UIKit.UIColor? {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  #endif
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = VFTeKYC.DataResponse<Value, VFTeKYC.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: VFTeKYC.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : VFTeKYC.ResponseSerializer
  public init<Serializer>(_ request: VFTeKYC.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : VFTeKYC.DataResponseSerializerProtocol
  #if compiler(>=5.3) && $NonescapableTypes
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, VFTeKYC.AFError>, Swift.Never>
  #endif
  public func value() -> Combine.AnyPublisher<Value, VFTeKYC.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == VFTeKYC.DataResponse<Value, VFTeKYC.AFError>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension VFTeKYC.DataResponsePublisher where Value == Foundation.Data? {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: VFTeKYC.DataRequest, queue: Dispatch.DispatchQueue)
  #endif
}
extension VFTeKYC.DataRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> VFTeKYC.DataResponsePublisher<T> where Serializer : VFTeKYC.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: any VFTeKYC.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> VFTeKYC.DataResponsePublisher<Foundation.Data>
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: any VFTeKYC.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> VFTeKYC.DataResponsePublisher<Swift.String>
  #endif
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any VFTeKYC.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<VFTeKYC.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> VFTeKYC.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any VFTeKYC.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> VFTeKYC.DataResponsePublisher<T> where T : Swift.Decodable
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(queue: Dispatch.DispatchQueue = .main) -> VFTeKYC.DataResponsePublisher<Foundation.Data?>
  #endif
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataStreamPublisher<Value> : Combine.Publisher {
  public typealias Output = VFTeKYC.DataStreamRequest.Stream<Value, VFTeKYC.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: VFTeKYC.DataStreamRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : VFTeKYC.DataStreamSerializer
  #if compiler(>=5.3) && $NonescapableTypes
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, VFTeKYC.AFError>, Swift.Never>
  #endif
  public func value() -> Combine.AnyPublisher<Value, VFTeKYC.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == VFTeKYC.DataStreamRequest.Stream<Value, VFTeKYC.AFError>
}
extension VFTeKYC.DataStreamRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> VFTeKYC.DataStreamPublisher<Serializer.SerializedObject> where Serializer : VFTeKYC.DataStreamSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishData(queue: Dispatch.DispatchQueue = .main) -> VFTeKYC.DataStreamPublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishString(queue: Dispatch.DispatchQueue = .main) -> VFTeKYC.DataStreamPublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), preprocessor: any VFTeKYC.DataPreprocessor = PassthroughPreprocessor()) -> VFTeKYC.DataStreamPublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DownloadResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = VFTeKYC.DownloadResponse<Value, VFTeKYC.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: VFTeKYC.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : VFTeKYC.ResponseSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init<Serializer>(_ request: VFTeKYC.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : VFTeKYC.DownloadResponseSerializerProtocol
  #if compiler(>=5.3) && $NonescapableTypes
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, VFTeKYC.AFError>, Swift.Never>
  #endif
  public func value() -> Combine.AnyPublisher<Value, VFTeKYC.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == VFTeKYC.DownloadResponse<Value, VFTeKYC.AFError>
}
extension VFTeKYC.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> VFTeKYC.DownloadResponsePublisher<T> where Serializer : VFTeKYC.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> VFTeKYC.DownloadResponsePublisher<T> where Serializer : VFTeKYC.DownloadResponseSerializerProtocol, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishURL(queue: Dispatch.DispatchQueue = .main) -> VFTeKYC.DownloadResponsePublisher<Foundation.URL>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: any VFTeKYC.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> VFTeKYC.DownloadResponsePublisher<Foundation.Data>
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: any VFTeKYC.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> VFTeKYC.DownloadResponsePublisher<Swift.String>
  #endif
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any VFTeKYC.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<VFTeKYC.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> VFTeKYC.DownloadResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any VFTeKYC.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any VFTeKYC.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<VFTeKYC.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> VFTeKYC.DownloadResponsePublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension VFTeKYC.DownloadResponsePublisher where Value == Foundation.URL? {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: VFTeKYC.DownloadRequest, queue: Dispatch.DispatchQueue)
  #endif
}
extension VFTeKYC.DownloadRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(on queue: Dispatch.DispatchQueue = .main) -> VFTeKYC.DownloadResponsePublisher<Foundation.URL?>
  #endif
}
public struct VFTFaceMatching : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum SwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension VFTeKYC.SwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct JSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  public mutating func merge(with other: VFTeKYC.JSON) throws
  public func merged(with other: VFTeKYC.JSON) throws -> VFTeKYC.JSON
  public var type: VFTeKYC.`Type` {
    get
  }
  public var error: VFTeKYC.SwiftyJSONError? {
    get
  }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: VFTeKYC.JSON {
    get
  }
  public static var null: VFTeKYC.JSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: VFTeKYC.Index<T>, rhs: VFTeKYC.Index<T>) -> Swift.Bool
  public static func < (lhs: VFTeKYC.Index<T>, rhs: VFTeKYC.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = VFTeKYC.Index<VFTeKYC.JSON>
public typealias JSONRawIndex = VFTeKYC.Index<Any>
extension VFTeKYC.JSON : Swift.Collection {
  public typealias Index = VFTeKYC.JSONRawIndex
  public var startIndex: VFTeKYC.JSON.Index {
    get
  }
  public var endIndex: VFTeKYC.JSON.Index {
    get
  }
  public func index(after i: VFTeKYC.JSON.Index) -> VFTeKYC.JSON.Index
  public subscript(position: VFTeKYC.JSON.Index) -> (Swift.String, VFTeKYC.JSON) {
    get
  }
  public typealias Element = (Swift.String, VFTeKYC.JSON)
  public typealias Indices = Swift.DefaultIndices<VFTeKYC.JSON>
  public typealias Iterator = Swift.IndexingIterator<VFTeKYC.JSON>
  public typealias SubSequence = Swift.Slice<VFTeKYC.JSON>
}
public enum JSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: VFTeKYC.JSONKey { get }
}
extension Swift.Int : VFTeKYC.JSONSubscriptType {
  public var jsonKey: VFTeKYC.JSONKey {
    get
  }
}
extension Swift.String : VFTeKYC.JSONSubscriptType {
  public var jsonKey: VFTeKYC.JSONKey {
    get
  }
}
extension VFTeKYC.JSON {
  public subscript(path: [any VFTeKYC.JSONSubscriptType]) -> VFTeKYC.JSON {
    get
    set
  }
  public subscript(path: any VFTeKYC.JSONSubscriptType...) -> VFTeKYC.JSON {
    get
    set
  }
}
extension VFTeKYC.JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension VFTeKYC.JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension VFTeKYC.JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension VFTeKYC.JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension VFTeKYC.JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension VFTeKYC.JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension VFTeKYC.JSON : Swift.RawRepresentable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Any)
  #endif
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  #if compiler(>=5.3) && $NonescapableTypes
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func rawString(_ options: [VFTeKYC.writingOptionsKeys : Any]) -> Swift.String?
  #endif
  public typealias RawValue = Any
}
extension VFTeKYC.JSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension VFTeKYC.JSON {
  #if compiler(>=5.3) && $NonescapableTypes
  public var array: [VFTeKYC.JSON]? {
    get
  }
  #endif
  public var arrayValue: [VFTeKYC.JSON] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var arrayObject: [Any]? {
    get
    set
  }
  #endif
}
extension VFTeKYC.JSON {
  #if compiler(>=5.3) && $NonescapableTypes
  public var dictionary: [Swift.String : VFTeKYC.JSON]? {
    get
  }
  #endif
  public var dictionaryValue: [Swift.String : VFTeKYC.JSON] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
  #endif
}
extension VFTeKYC.JSON {
  #if compiler(>=5.3) && $NonescapableTypes
  public var bool: Swift.Bool? {
    get
    set
  }
  #endif
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension VFTeKYC.JSON {
  #if compiler(>=5.3) && $NonescapableTypes
  public var string: Swift.String? {
    get
    set
  }
  #endif
  public var stringValue: Swift.String {
    get
    set
  }
}
extension VFTeKYC.JSON {
  #if compiler(>=5.3) && $NonescapableTypes
  public var number: Foundation.NSNumber? {
    get
    set
  }
  #endif
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension VFTeKYC.JSON {
  #if compiler(>=5.3) && $NonescapableTypes
  public var null: Foundation.NSNull? {
    get
    set
  }
  #endif
  public func exists() -> Swift.Bool
}
extension VFTeKYC.JSON {
  #if compiler(>=5.3) && $NonescapableTypes
  public var url: Foundation.URL? {
    get
    set
  }
  #endif
}
extension VFTeKYC.JSON {
  #if compiler(>=5.3) && $NonescapableTypes
  public var double: Swift.Double? {
    get
    set
  }
  #endif
  public var doubleValue: Swift.Double {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var float: Swift.Float? {
    get
    set
  }
  #endif
  public var floatValue: Swift.Float {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var int: Swift.Int? {
    get
    set
  }
  #endif
  public var intValue: Swift.Int {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var uInt: Swift.UInt? {
    get
    set
  }
  #endif
  public var uIntValue: Swift.UInt {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var int8: Swift.Int8? {
    get
    set
  }
  #endif
  public var int8Value: Swift.Int8 {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  #endif
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var int16: Swift.Int16? {
    get
    set
  }
  #endif
  public var int16Value: Swift.Int16 {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  #endif
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var int32: Swift.Int32? {
    get
    set
  }
  #endif
  public var int32Value: Swift.Int32 {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  #endif
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var int64: Swift.Int64? {
    get
    set
  }
  #endif
  public var int64Value: Swift.Int64 {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  #endif
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension VFTeKYC.JSON : Swift.Comparable {
}
public func == (lhs: VFTeKYC.JSON, rhs: VFTeKYC.JSON) -> Swift.Bool
public func <= (lhs: VFTeKYC.JSON, rhs: VFTeKYC.JSON) -> Swift.Bool
public func >= (lhs: VFTeKYC.JSON, rhs: VFTeKYC.JSON) -> Swift.Bool
public func > (lhs: VFTeKYC.JSON, rhs: VFTeKYC.JSON) -> Swift.Bool
public func < (lhs: VFTeKYC.JSON, rhs: VFTeKYC.JSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: VFTeKYC.writingOptionsKeys, b: VFTeKYC.writingOptionsKeys) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension VFTeKYC.JSON : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct VFTBackSide : Swift.Codable {
  public let ocrInfo: VFTeKYC.VFTOcrInfo?
  public let cardType: Swift.String?
  public let screenCapValid: VFTeKYC.VFTScreenCapValid?
  public let clippedCornerValid: VFTeKYC.VFTClippedCornerValid?
  public let blurValid: VFTeKYC.VFTBlurValid?
  public let overExposeValid: VFTeKYC.VFTOverExposeValid?
  public let cardOverflowValid: VFTeKYC.VFTCardOverflowValid?
  public let rotateAngle: Swift.Int?
  public let mrzValid: VFTeKYC.VFTMrzValid?
  public let idValid: VFTeKYC.VFTBackSideIdValid?
  public let photocopyValid: VFTeKYC.VFTBackSidePhotocopyValid?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTBackSideIdValid : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTBackSidePhotocopyValid : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency public class FirstVC : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func viewDidLoad()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  #endif
  @objc deinit
}
public protocol CachedResponseHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
  #endif
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static let cache: VFTeKYC.ResponseCacher
  public static let doNotCache: VFTeKYC.ResponseCacher
  public let behavior: VFTeKYC.ResponseCacher.Behavior
  public init(behavior: VFTeKYC.ResponseCacher.Behavior)
}
extension VFTeKYC.ResponseCacher : VFTeKYC.CachedResponseHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
  #endif
}
extension VFTeKYC.CachedResponseHandler where Self == VFTeKYC.ResponseCacher {
  public static var cache: VFTeKYC.ResponseCacher {
    get
  }
  public static var doNotCache: VFTeKYC.ResponseCacher {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public static func modify(using closure: @escaping (Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?) -> VFTeKYC.ResponseCacher
  #endif
}
public struct VFTScreenCapValid : Swift.Codable {
  public let isScreencap: Swift.Bool?
  public let screencapScore: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VFTFieldDetail : Swift.Codable {
  public let mrzInfo: Swift.Bool?
  public let faceInfo: Swift.Bool?
  public let citizenInfo: Swift.Bool?
  public let signatureInfo: Swift.Bool?
  public let publicKeyInfo: Swift.Bool?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum CAGradientPoint {
  case topLeft
  case centerLeft
  case bottomLeft
  case topCenter
  case center
  case bottomCenter
  case topRight
  case centerRight
  case bottomRight
  public static func == (a: VFTeKYC.CAGradientPoint, b: VFTeKYC.CAGradientPoint) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public protocol EFPointStyle {
  @objc func fillRect(context: CoreGraphics.CGContext, rect: CoreFoundation.CGRect, isStatic: Swift.Bool)
}
@_inheritsConvenienceInitializers @objc public class EFSquarePointStyle : ObjectiveC.NSObject, VFTeKYC.EFPointStyle {
  @objc public func fillRect(context: CoreGraphics.CGContext, rect: CoreFoundation.CGRect, isStatic: Swift.Bool)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class EFCirclePointStyle : ObjectiveC.NSObject, VFTeKYC.EFPointStyle {
  @objc public func fillRect(context: CoreGraphics.CGContext, rect: CoreFoundation.CGRect, isStatic: Swift.Bool)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class EFDiamondPointStyle : ObjectiveC.NSObject, VFTeKYC.EFPointStyle {
  @objc public func fillRect(context: CoreGraphics.CGContext, rect: CoreFoundation.CGRect, isStatic: Swift.Bool)
  @objc override dynamic public init()
  @objc deinit
}
extension VFTeKYC.EFPointStyle where Self == VFTeKYC.EFSquarePointStyle {
  public static var square: VFTeKYC.EFSquarePointStyle {
    get
  }
}
extension VFTeKYC.EFPointStyle where Self == VFTeKYC.EFCirclePointStyle {
  public static var circle: VFTeKYC.EFCirclePointStyle {
    get
  }
}
extension VFTeKYC.EFPointStyle where Self == VFTeKYC.EFDiamondPointStyle {
  public static var diamond: VFTeKYC.EFDiamondPointStyle {
    get
  }
}
open class ServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : any VFTeKYC.ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : any VFTeKYC.ServerTrustEvaluating])
  #if compiler(>=5.3) && $NonescapableTypes
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> (any VFTeKYC.ServerTrustEvaluating)?
  #endif
  @objc deinit
}
public protocol ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class DefaultTrustEvaluator : VFTeKYC.ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RevocationTrustEvaluator : VFTeKYC.ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static let crl: VFTeKYC.RevocationTrustEvaluator.Options
    public static let networkAccessDisabled: VFTeKYC.RevocationTrustEvaluator.Options
    public static let ocsp: VFTeKYC.RevocationTrustEvaluator.Options
    public static let preferCRL: VFTeKYC.RevocationTrustEvaluator.Options
    public static let requirePositiveResponse: VFTeKYC.RevocationTrustEvaluator.Options
    public static let any: VFTeKYC.RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias ArrayLiteralElement = VFTeKYC.RevocationTrustEvaluator.Options
    public typealias Element = VFTeKYC.RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: VFTeKYC.RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension VFTeKYC.ServerTrustEvaluating where Self == VFTeKYC.RevocationTrustEvaluator {
  public static var revocationChecking: VFTeKYC.RevocationTrustEvaluator {
    get
  }
  public static func revocationChecking(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: VFTeKYC.RevocationTrustEvaluator.Options = .any) -> VFTeKYC.RevocationTrustEvaluator
}
final public class PinnedCertificatesTrustEvaluator : VFTeKYC.ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension VFTeKYC.ServerTrustEvaluating where Self == VFTeKYC.PinnedCertificatesTrustEvaluator {
  public static var pinnedCertificates: VFTeKYC.PinnedCertificatesTrustEvaluator {
    get
  }
  public static func pinnedCertificates(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> VFTeKYC.PinnedCertificatesTrustEvaluator
}
final public class PublicKeysTrustEvaluator : VFTeKYC.ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension VFTeKYC.ServerTrustEvaluating where Self == VFTeKYC.PublicKeysTrustEvaluator {
  public static var publicKeys: VFTeKYC.PublicKeysTrustEvaluator {
    get
  }
  public static func publicKeys(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> VFTeKYC.PublicKeysTrustEvaluator
}
final public class CompositeTrustEvaluator : VFTeKYC.ServerTrustEvaluating {
  public init(evaluators: [any VFTeKYC.ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension VFTeKYC.ServerTrustEvaluating where Self == VFTeKYC.CompositeTrustEvaluator {
  public static func composite(evaluators: [any VFTeKYC.ServerTrustEvaluating]) -> VFTeKYC.CompositeTrustEvaluator
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias DisabledEvaluator = VFTeKYC.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : VFTeKYC.ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Swift.Array where Element == any VFTeKYC.ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Foundation.Bundle : VFTeKYC.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension VFTeKYC.AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension Security.SecTrust : VFTeKYC.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension VFTeKYC.AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> any Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> any Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension Security.SecPolicy : VFTeKYC.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension VFTeKYC.AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static let `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: VFTeKYC.RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Swift.Array : VFTeKYC.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension VFTeKYC.AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension Security.SecCertificate : VFTeKYC.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension VFTeKYC.AlamofireExtension where ExtendedType == Security.SecCertificate {
  #if compiler(>=5.3) && $NonescapableTypes
  public var publicKey: Security.SecKey? {
    get
  }
  #endif
}
extension Swift.Int32 : VFTeKYC.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension VFTeKYC.AlamofireExtension where ExtendedType == Swift.Int32 {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension Security.SecTrustResultType : VFTeKYC.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension VFTeKYC.AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
public struct VFTSignatureCheckDetail : Swift.Codable {
  public let accuracy: Swift.Int?
  public let dg13Info: VFTeKYC.VFTDg13Info?
  public let fieldDetail: VFTeKYC.VFTFieldDetail?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol EventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  #if compiler(>=5.3) && $NonescapableTypes
  func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  #endif
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  #if compiler(>=5.3) && $NonescapableTypes
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  #endif
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func request(_ request: VFTeKYC.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: VFTeKYC.Request, didFailToCreateURLRequestWithError error: VFTeKYC.AFError)
  func request(_ request: VFTeKYC.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func request(_ request: VFTeKYC.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: VFTeKYC.AFError)
  func request(_ request: VFTeKYC.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: VFTeKYC.Request, didCreateTask task: Foundation.URLSessionTask)
  func request(_ request: VFTeKYC.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: VFTeKYC.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: VFTeKYC.AFError)
  #if compiler(>=5.3) && $NonescapableTypes
  func request(_ request: VFTeKYC.Request, didCompleteTask task: Foundation.URLSessionTask, with error: VFTeKYC.AFError?)
  #endif
  func requestIsRetrying(_ request: VFTeKYC.Request)
  func requestDidFinish(_ request: VFTeKYC.Request)
  func requestDidResume(_ request: VFTeKYC.Request)
  func request(_ request: VFTeKYC.Request, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ request: VFTeKYC.Request)
  func request(_ request: VFTeKYC.Request, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ request: VFTeKYC.Request)
  func request(_ request: VFTeKYC.Request, didCancelTask task: Foundation.URLSessionTask)
  #if compiler(>=5.3) && $NonescapableTypes
  func request(_ request: VFTeKYC.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func request(_ request: VFTeKYC.DataRequest, didParseResponse response: VFTeKYC.DataResponse<Foundation.Data?, VFTeKYC.AFError>)
  #endif
  func request<Value>(_ request: VFTeKYC.DataRequest, didParseResponse response: VFTeKYC.DataResponse<Value, VFTeKYC.AFError>)
  #if compiler(>=5.3) && $NonescapableTypes
  func request(_ request: VFTeKYC.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func request<Value>(_ request: VFTeKYC.DataStreamRequest, didParseStream result: Swift.Result<Value, VFTeKYC.AFError>)
  #endif
  func request(_ request: VFTeKYC.UploadRequest, didCreateUploadable uploadable: VFTeKYC.UploadRequest.Uploadable)
  func request(_ request: VFTeKYC.UploadRequest, didFailToCreateUploadableWithError error: VFTeKYC.AFError)
  func request(_ request: VFTeKYC.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  #if compiler(>=5.3) && $NonescapableTypes
  func request(_ request: VFTeKYC.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, VFTeKYC.AFError>)
  #endif
  func request(_ request: VFTeKYC.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  #if compiler(>=5.3) && $NonescapableTypes
  func request(_ request: VFTeKYC.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func request(_ request: VFTeKYC.DownloadRequest, didParseResponse response: VFTeKYC.DownloadResponse<Foundation.URL?, VFTeKYC.AFError>)
  #endif
  func request<Value>(_ request: VFTeKYC.DownloadRequest, didParseResponse response: VFTeKYC.DownloadResponse<Value, VFTeKYC.AFError>)
}
extension VFTeKYC.EventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  #endif
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  #if compiler(>=5.3) && $NonescapableTypes
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  #endif
  public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func request(_ request: VFTeKYC.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: VFTeKYC.Request, didFailToCreateURLRequestWithError error: VFTeKYC.AFError)
  public func request(_ request: VFTeKYC.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func request(_ request: VFTeKYC.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: VFTeKYC.AFError)
  public func request(_ request: VFTeKYC.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: VFTeKYC.Request, didCreateTask task: Foundation.URLSessionTask)
  public func request(_ request: VFTeKYC.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: VFTeKYC.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: VFTeKYC.AFError)
  #if compiler(>=5.3) && $NonescapableTypes
  public func request(_ request: VFTeKYC.Request, didCompleteTask task: Foundation.URLSessionTask, with error: VFTeKYC.AFError?)
  #endif
  public func requestIsRetrying(_ request: VFTeKYC.Request)
  public func requestDidFinish(_ request: VFTeKYC.Request)
  public func requestDidResume(_ request: VFTeKYC.Request)
  public func request(_ request: VFTeKYC.Request, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ request: VFTeKYC.Request)
  public func request(_ request: VFTeKYC.Request, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ request: VFTeKYC.Request)
  public func request(_ request: VFTeKYC.Request, didCancelTask task: Foundation.URLSessionTask)
  #if compiler(>=5.3) && $NonescapableTypes
  public func request(_ request: VFTeKYC.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func request(_ request: VFTeKYC.DataRequest, didParseResponse response: VFTeKYC.DataResponse<Foundation.Data?, VFTeKYC.AFError>)
  #endif
  public func request<Value>(_ request: VFTeKYC.DataRequest, didParseResponse response: VFTeKYC.DataResponse<Value, VFTeKYC.AFError>)
  #if compiler(>=5.3) && $NonescapableTypes
  public func request(_ request: VFTeKYC.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func request<Value>(_ request: VFTeKYC.DataStreamRequest, didParseStream result: Swift.Result<Value, VFTeKYC.AFError>)
  #endif
  public func request(_ request: VFTeKYC.UploadRequest, didCreateUploadable uploadable: VFTeKYC.UploadRequest.Uploadable)
  public func request(_ request: VFTeKYC.UploadRequest, didFailToCreateUploadableWithError error: VFTeKYC.AFError)
  public func request(_ request: VFTeKYC.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  #if compiler(>=5.3) && $NonescapableTypes
  public func request(_ request: VFTeKYC.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, VFTeKYC.AFError>)
  #endif
  public func request(_ request: VFTeKYC.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  #if compiler(>=5.3) && $NonescapableTypes
  public func request(_ request: VFTeKYC.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func request(_ request: VFTeKYC.DownloadRequest, didParseResponse response: VFTeKYC.DownloadResponse<Foundation.URL?, VFTeKYC.AFError>)
  #endif
  public func request<Value>(_ request: VFTeKYC.DownloadRequest, didParseResponse response: VFTeKYC.DownloadResponse<Value, VFTeKYC.AFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : VFTeKYC.EventMonitor {
  final public let queue: Dispatch.DispatchQueue
  #if compiler(>=5.3) && $NonescapableTypes
  final public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  #endif
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  #endif
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func request(_ request: VFTeKYC.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: VFTeKYC.Request, didFailToCreateURLRequestWithError error: VFTeKYC.AFError)
  final public func request(_ request: VFTeKYC.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func request(_ request: VFTeKYC.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: VFTeKYC.AFError)
  final public func request(_ request: VFTeKYC.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: VFTeKYC.Request, didCreateTask task: Foundation.URLSessionTask)
  final public func request(_ request: VFTeKYC.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func request(_ request: VFTeKYC.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: VFTeKYC.AFError)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func request(_ request: VFTeKYC.Request, didCompleteTask task: Foundation.URLSessionTask, with error: VFTeKYC.AFError?)
  #endif
  final public func requestIsRetrying(_ request: VFTeKYC.Request)
  final public func requestDidFinish(_ request: VFTeKYC.Request)
  final public func requestDidResume(_ request: VFTeKYC.Request)
  final public func request(_ request: VFTeKYC.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ request: VFTeKYC.Request)
  final public func request(_ request: VFTeKYC.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ request: VFTeKYC.Request)
  final public func request(_ request: VFTeKYC.Request, didCancelTask task: Foundation.URLSessionTask)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func request(_ request: VFTeKYC.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func request(_ request: VFTeKYC.DataRequest, didParseResponse response: VFTeKYC.DataResponse<Foundation.Data?, VFTeKYC.AFError>)
  #endif
  final public func request<Value>(_ request: VFTeKYC.DataRequest, didParseResponse response: VFTeKYC.DataResponse<Value, VFTeKYC.AFError>)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func request(_ request: VFTeKYC.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func request<Value>(_ request: VFTeKYC.DataStreamRequest, didParseStream result: Swift.Result<Value, VFTeKYC.AFError>)
  #endif
  final public func request(_ request: VFTeKYC.UploadRequest, didCreateUploadable uploadable: VFTeKYC.UploadRequest.Uploadable)
  final public func request(_ request: VFTeKYC.UploadRequest, didFailToCreateUploadableWithError error: VFTeKYC.AFError)
  final public func request(_ request: VFTeKYC.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func request(_ request: VFTeKYC.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, VFTeKYC.AFError>)
  #endif
  final public func request(_ request: VFTeKYC.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func request(_ request: VFTeKYC.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func request(_ request: VFTeKYC.DownloadRequest, didParseResponse response: VFTeKYC.DownloadResponse<Foundation.URL?, VFTeKYC.AFError>)
  #endif
  final public func request<Value>(_ request: VFTeKYC.DownloadRequest, didParseResponse response: VFTeKYC.DownloadResponse<Value, VFTeKYC.AFError>)
  @objc deinit
}
open class ClosureEventMonitor : VFTeKYC.EventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, (any Swift.Error)?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, (any Swift.Error)?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((VFTeKYC.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((VFTeKYC.Request, VFTeKYC.AFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((VFTeKYC.Request, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((VFTeKYC.Request, Foundation.URLRequest, VFTeKYC.AFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((VFTeKYC.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((VFTeKYC.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((VFTeKYC.Request, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((VFTeKYC.Request, Foundation.URLSessionTask, VFTeKYC.AFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((VFTeKYC.Request, Foundation.URLSessionTask, VFTeKYC.AFError?) -> Swift.Void)?
  open var requestIsRetrying: ((VFTeKYC.Request) -> Swift.Void)?
  open var requestDidFinish: ((VFTeKYC.Request) -> Swift.Void)?
  open var requestDidResume: ((VFTeKYC.Request) -> Swift.Void)?
  open var requestDidResumeTask: ((VFTeKYC.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((VFTeKYC.Request) -> Swift.Void)?
  open var requestDidSuspendTask: ((VFTeKYC.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((VFTeKYC.Request) -> Swift.Void)?
  open var requestDidCancelTask: ((VFTeKYC.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((VFTeKYC.DataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, VFTeKYC.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((VFTeKYC.DataRequest, VFTeKYC.DataResponse<Foundation.Data?, VFTeKYC.AFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((VFTeKYC.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, VFTeKYC.Request.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((VFTeKYC.UploadRequest, VFTeKYC.UploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((VFTeKYC.UploadRequest, VFTeKYC.AFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((VFTeKYC.UploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((VFTeKYC.DownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, VFTeKYC.AFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((VFTeKYC.DownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((VFTeKYC.DownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, VFTeKYC.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((VFTeKYC.DownloadRequest, VFTeKYC.DownloadResponse<Foundation.URL?, VFTeKYC.AFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  #if compiler(>=5.3) && $NonescapableTypes
  open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  #endif
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  #if compiler(>=5.3) && $NonescapableTypes
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  #endif
  open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func request(_ request: VFTeKYC.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: VFTeKYC.Request, didFailToCreateURLRequestWithError error: VFTeKYC.AFError)
  open func request(_ request: VFTeKYC.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func request(_ request: VFTeKYC.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: VFTeKYC.AFError)
  open func request(_ request: VFTeKYC.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: VFTeKYC.Request, didCreateTask task: Foundation.URLSessionTask)
  open func request(_ request: VFTeKYC.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func request(_ request: VFTeKYC.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: VFTeKYC.AFError)
  #if compiler(>=5.3) && $NonescapableTypes
  open func request(_ request: VFTeKYC.Request, didCompleteTask task: Foundation.URLSessionTask, with error: VFTeKYC.AFError?)
  #endif
  open func requestIsRetrying(_ request: VFTeKYC.Request)
  open func requestDidFinish(_ request: VFTeKYC.Request)
  open func requestDidResume(_ request: VFTeKYC.Request)
  public func request(_ request: VFTeKYC.Request, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ request: VFTeKYC.Request)
  public func request(_ request: VFTeKYC.Request, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ request: VFTeKYC.Request)
  public func request(_ request: VFTeKYC.Request, didCancelTask task: Foundation.URLSessionTask)
  #if compiler(>=5.3) && $NonescapableTypes
  open func request(_ request: VFTeKYC.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func request(_ request: VFTeKYC.DataRequest, didParseResponse response: VFTeKYC.DataResponse<Foundation.Data?, VFTeKYC.AFError>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func request(_ request: VFTeKYC.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  open func request(_ request: VFTeKYC.UploadRequest, didCreateUploadable uploadable: VFTeKYC.UploadRequest.Uploadable)
  open func request(_ request: VFTeKYC.UploadRequest, didFailToCreateUploadableWithError error: VFTeKYC.AFError)
  open func request(_ request: VFTeKYC.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  #if compiler(>=5.3) && $NonescapableTypes
  open func request(_ request: VFTeKYC.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, VFTeKYC.AFError>)
  #endif
  open func request(_ request: VFTeKYC.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  #if compiler(>=5.3) && $NonescapableTypes
  open func request(_ request: VFTeKYC.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: VFTeKYC.Request.ValidationResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func request(_ request: VFTeKYC.DownloadRequest, didParseResponse response: VFTeKYC.DownloadResponse<Foundation.URL?, VFTeKYC.AFError>)
  #endif
  @objc deinit
}
extension VFTeKYC.Reachability.NetworkStatus : Swift.Equatable {}
extension VFTeKYC.Reachability.NetworkStatus : Swift.Hashable {}
extension VFTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Equatable {}
extension VFTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Hashable {}
extension VFTeKYC.URLEncodedFormParameterEncoder.Destination : Swift.Equatable {}
extension VFTeKYC.URLEncodedFormParameterEncoder.Destination : Swift.Hashable {}
extension VFTeKYC.URLEncodedFormEncoder.ArrayEncoding : Swift.Equatable {}
extension VFTeKYC.URLEncodedFormEncoder.ArrayEncoding : Swift.Hashable {}
extension VFTeKYC.URLEncodedFormEncoder.BoolEncoding : Swift.Equatable {}
extension VFTeKYC.URLEncodedFormEncoder.BoolEncoding : Swift.Hashable {}
extension VFTeKYC.URLEncodedFormEncoder.SpaceEncoding : Swift.Equatable {}
extension VFTeKYC.URLEncodedFormEncoder.SpaceEncoding : Swift.Hashable {}
extension VFTeKYC.EFWatermarkMode : Swift.Equatable {}
extension VFTeKYC.EFWatermarkMode : Swift.Hashable {}
extension VFTeKYC.EFWatermarkMode : Swift.RawRepresentable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.CertificateType : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.CertificateType : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.CertificateItem : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.CertificateItem : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.CertificateItem : Swift.RawRepresentable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.DataGroupId : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.DataGroupId : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.DataGroupId : Swift.RawRepresentable {}
extension VFTeKYC.SecureMessagingSupportedAlgorithms : Swift.Equatable {}
extension VFTeKYC.SecureMessagingSupportedAlgorithms : Swift.Hashable {}
extension VFTeKYC.PassportAuthenticationStatus : Swift.Equatable {}
extension VFTeKYC.PassportAuthenticationStatus : Swift.Hashable {}
extension VFTeKYC.LogLevel : Swift.Equatable {}
extension VFTeKYC.LogLevel : Swift.Hashable {}
extension VFTeKYC.LogLevel : Swift.RawRepresentable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.DocTypeEnum : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.DocTypeEnum : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension VFTeKYC.DocTypeEnum : Swift.RawRepresentable {}
extension VFTeKYC.PACEMappingType : Swift.Equatable {}
extension VFTeKYC.PACEMappingType : Swift.Hashable {}
extension VFTeKYC.EFInputCorrectionLevel : Swift.Equatable {}
extension VFTeKYC.EFInputCorrectionLevel : Swift.Hashable {}
extension VFTeKYC.EFInputCorrectionLevel : Swift.RawRepresentable {}
extension VFTeKYC.AuthenticationError : Swift.Equatable {}
extension VFTeKYC.AuthenticationError : Swift.Hashable {}
extension VFTeKYC.URLEncoding.Destination : Swift.Equatable {}
extension VFTeKYC.URLEncoding.Destination : Swift.Hashable {}
extension VFTeKYC.URLEncoding.ArrayEncoding : Swift.Equatable {}
extension VFTeKYC.URLEncoding.ArrayEncoding : Swift.Hashable {}
extension VFTeKYC.URLEncoding.BoolEncoding : Swift.Equatable {}
extension VFTeKYC.URLEncoding.BoolEncoding : Swift.Hashable {}
extension VFTeKYC.JSONEncoding.Error : Swift.Equatable {}
extension VFTeKYC.JSONEncoding.Error : Swift.Hashable {}
@available(*, deprecated, message: "Use EFPointStyle instead.")
extension VFTeKYC.EFPointShape : Swift.Equatable {}
@available(*, deprecated, message: "Use EFPointStyle instead.")
extension VFTeKYC.EFPointShape : Swift.Hashable {}
@available(*, deprecated, message: "Use EFPointStyle instead.")
extension VFTeKYC.EFPointShape : Swift.RawRepresentable {}
extension VFTeKYC.VFTSanityForgeryError : Swift.Equatable {}
extension VFTeKYC.VFTSanityForgeryError : Swift.Hashable {}
extension VFTeKYC.Request.State : Swift.Equatable {}
extension VFTeKYC.Request.State : Swift.Hashable {}
extension VFTeKYC.HKProgressHUD.HudMode : Swift.Equatable {}
extension VFTeKYC.HKProgressHUD.HudMode : Swift.Hashable {}
extension VFTeKYC.HKProgressHUD.HudAnimation : Swift.Equatable {}
extension VFTeKYC.HKProgressHUD.HudAnimation : Swift.Hashable {}
extension VFTeKYC.ProgressHUDBackgroundView.BackgroundStyle : Swift.Equatable {}
extension VFTeKYC.ProgressHUDBackgroundView.BackgroundStyle : Swift.Hashable {}
extension VFTeKYC.SwiftyJSONError : Swift.Equatable {}
extension VFTeKYC.SwiftyJSONError : Swift.Hashable {}
extension VFTeKYC.SwiftyJSONError : Swift.RawRepresentable {}
extension VFTeKYC.`Type` : Swift.Equatable {}
extension VFTeKYC.`Type` : Swift.Hashable {}
extension VFTeKYC.`Type` : Swift.RawRepresentable {}
extension VFTeKYC.writingOptionsKeys : Swift.Equatable {}
extension VFTeKYC.writingOptionsKeys : Swift.Hashable {}
extension VFTeKYC.CAGradientPoint : Swift.Equatable {}
extension VFTeKYC.CAGradientPoint : Swift.Hashable {}
